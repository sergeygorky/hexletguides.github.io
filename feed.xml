<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru_RU"><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://guides.hexlet.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://guides.hexlet.io/" rel="alternate" type="text/html" hreflang="ru_RU" /><updated>2021-06-08T13:11:04+00:00</updated><id>https://guides.hexlet.io/feed.xml</id><title type="html">Гайды для программистов</title><subtitle>Полезные статьи и гайды для разработчиков
</subtitle><author><name>Kirill Mokevnin</name></author><entry><title type="html">Что такое “управление конфигурацией”?</title><link href="https://guides.hexlet.io/configuration-management/" rel="alternate" type="text/html" title="Что такое “управление конфигурацией”?" /><published>2021-06-04T00:00:00+00:00</published><updated>2021-06-04T00:00:00+00:00</updated><id>https://guides.hexlet.io/configuration-management</id><content type="html" xml:base="https://guides.hexlet.io/configuration-management/">&lt;p&gt;Сайты это не только код, но и инфраструктура для их запуска. В первую очередь, в нее входят сервера, на которых крутится код, база данных и различные вспомогательные системы. Иногда все это помещается на один сервер, в более сложных ситуациях количество серверов измеряется тысячами, а для обслуживания таких систем привлекаются целые команды инженеров (разного рода администраторов). Независимо от размера сайта, проблемы обслуживания инфраструктуры у всех очень похожие. Поговорим об одной конкретной – настройке сервера.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Существуют подходы, которые позволяют избежать прямого взаимодействия с инфраструктурой. В рамках статьи они не рассматриваются, но знать про них полезно. К ним относятся: классические хостинги с предустановленным софтом, serverless, хостинги статических сайтов, PaaS решения&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;В подавляющем большинстве случаев, сервера арендуются у хостинговых компаний, таких как DigitalOcean или AWS. Делается это за 5 минут нажатием буквально нескольких кнопок. Нас попросят выбрать характеристики сервера, операционную систему и датацентр, в котором она будет развернута. В результате мы получаем машину (виртуальную), с предустановленной операционной системой и ip-адресом для входа по ssh.&lt;/p&gt;

&lt;p&gt;Новая машина содержит только основную операционную систему с небольшим набором предустановленных программ.&lt;/p&gt;</content><author><name>Кирилл Мокевнин</name></author><summary type="html">Сайты это не только код, но и инфраструктура для их запуска. В первую очередь, в нее входят сервера, на которых крутится код, база данных и различные вспомогательные системы. Иногда все это помещается на один сервер, в более сложных ситуациях количество серверов измеряется тысячами, а для обслуживания таких систем привлекаются целые команды инженеров (разного рода администраторов). Независимо от размера сайта, проблемы обслуживания инфраструктуры у всех очень похожие. Поговорим об одной конкретной – настройке сервера.</summary></entry><entry><title type="html">Что такое трекинг ошибок?</title><link href="https://guides.hexlet.io/error-tracking/" rel="alternate" type="text/html" title="Что такое трекинг ошибок?" /><published>2021-01-18T00:00:00+00:00</published><updated>2021-01-18T00:00:00+00:00</updated><id>https://guides.hexlet.io/error-tracking</id><content type="html" xml:base="https://guides.hexlet.io/error-tracking/">&lt;p&gt;Программ без ошибок не бывает. Их количество можно уменьшить с помощью системы типов, линтеров, тестов или даже целого отдела тестировщиков, но убрать совсем невозможно. Это реальность с которой мы живем и лучшее, что можно сделать, научиться эти ошибки отслеживать и быстро исправлять.&lt;/p&gt;

&lt;h2 id=&quot;как-не-надо-работать-с-ошибками&quot;&gt;Как не надо работать с ошибками&lt;/h2&gt;

&lt;p&gt;Как, часто, происходит в разработке. Программисты написали какой-то код, выпустили новую версию сайта/приложения и пошли дальше заниматься своими делами. В это время у некоторых пользователей обнаруживаются проблемы: что-то зависает, формы не отправляются, данные отображаются неправильно и так далее. Такое может продолжаться довольно долго, пока кто-то разгневанный не напишет письмо в службу поддержки. Затем по цепочке это долетает до программистов, которые пытаются понять у кого произошла ошибка, где она случилась, и при каких обстоятельствах. Начинаются выяснения всех подробностей с вероятным привлечением клиента, если тот согласится помочь. При таком подходе, большое количество ошибок остается незамеченным очень долго и, самое неприятное, пользователи уходят. Можно ли этого избежать? Оказывается можно.&lt;/p&gt;

&lt;h2 id=&quot;как-надо-работать-с-ошибками&quot;&gt;Как надо работать с ошибками&lt;/h2&gt;

&lt;p&gt;Существует целый класс сервисов называемых Error Trackers. Они в реальном времени собирают информацию о возникающих ошибках и оповещают об этом команду разработки. Эти сервисы работают буквально со всеми существующими платформами начиная от телевизоров, заканчивая мобильными приложениями и сайтами (и фронтенд и бекенд).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/error-tracking/rollbar-dashboard.jpg&quot; alt=&quot;Rollbar Dashboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Выше пример дашборда сервиса &lt;a href=&quot;https://rollbar.io/&quot;&gt;rollbar.io&lt;/a&gt;, который используется для всех проектов Хекслета. На дашборде выводится частота появления критичных ошибок за последние 24 часа по всем проектам. Этот график позволяет быстро оценить места, куда нужно внимательнее смотреть. А ниже вывод ошибок конкретного проекта. Судя по иконкам, большая часть ошибок прямо сейчас приходит из JavaScript.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/error-tracking/rollbar-project.jpg&quot; alt=&quot;Rollbar Project&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Каждый такой сервис сервис предоставляет библиотеки под разные языки и платформы, которые встраиваются в код и вызываются в случае возникновении ошибок. Эти библиотеки отправляют не только саму ошибку, но и информацию об окружении, которая может помочь. В нее могут входить данные о пользователе, о его браузере, о настройках приложения и так далее.&lt;/p&gt;

&lt;p&gt;В идеальном случае такая библиотека сразу &lt;a href=&quot;https://docs.rollbar.com/docs/rails&quot;&gt;интегрирована&lt;/a&gt; в какой-нибудь фреймворк, например Rails. Тогда не придется практически ничего настраивать, достаточно подключить библиотеку как плагин к фреймворку и дальше он начнет собирать ошибки сам, без дополнительного вмешательства. Если такой интеграции нет, то придется написать немного кода для связи своего приложения с библиотекой. Подробнее о том как это сделать, нужно смотреть в документации выбранного вами сервиса. &lt;a href=&quot;https://docs.rollbar.com/docs/react&quot;&gt;Вот&lt;/a&gt; пример интеграции Rollbar в React. После того как все заработает, пойманная ошибка будет выглядеть примерно так:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/error-tracking/rollbar-error.jpg&quot; alt=&quot;Rollbar Error&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Обратите внимание на меню сверху. По названиям вкладок видно сколько полезного извлекается из ошибки.&lt;/p&gt;

&lt;p&gt;Но поймать ошибку это только половина дела. Дальше нужно как-то оповестить команду, причем так, чтобы не завалить всех спамом. Дело в том, что ошибки обычно не происходят один раз. Если ошибка общая и количество пользователей большое, то можно легко поймать одну ошибку тысячи раз в минуту. И если бы на каждое возникновение уходила нотификация (на емейл или в слак), то такой сервис быстро бы отключили от источника питания.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/error-tracking/rollbar-notifications.jpg&quot; alt=&quot;Rollbar Error&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Поэтому подобные трекеры работают хитро. Когда ошибка произошла первый раз, то сервис высылает оповещение чтобы команда разработки могла оперативно среагировать на инцендент. Если ошибка возникает снова, то больше никаких оповещений. По крайней мере не на каждое возникновение. Оповещения например могут уходить на первое, десятое, сотое, тысячное и так далее возникновение. Это первая часть механизма. Дальше, когда выкатывается новая версия приложения, трекеры помечают ошибки как “поправленные”. Это позволяет легко отслеживать ошибки, которые либо забыли поправить, либо поправили неправильно. Поэтому обычно после деплоя начинают сыпаться оповещения) Для работы этого механизма нужно оповещать трекер о деплоях. Подробно об этом &lt;a href=&quot;https://docs.rollbar.com/docs/deploy-tracking&quot;&gt;написано в документации&lt;/a&gt; соответствующего трекера.&lt;/p&gt;

&lt;h2 id=&quot;выводы&quot;&gt;Выводы&lt;/h2&gt;

&lt;p&gt;Трекеры ошибок не игрушка, а серьезный инструмент, без которого невозможно представить себе ни один продакшен. В качестве трекера, при этом, может выступать как один из многих сервисов, так и специализированный софт (например &lt;a href=&quot;https://github.com/getsentry/sentry&quot;&gt;Sentry&lt;/a&gt;), установленный к себе на сервера в случае повышенных требований к безопасности.&lt;/p&gt;</content><author><name>Кирилл Мокевнин</name></author><summary type="html">Программ без ошибок не бывает. Их количество можно уменьшить с помощью системы типов, линтеров, тестов или даже целого отдела тестировщиков, но убрать совсем невозможно. Это реальность с которой мы живем и лучшее, что можно сделать, научиться эти ошибки отслеживать и быстро исправлять.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://guides.hexlet.io/assets/images/hosting/servers.png" /><media:content medium="image" url="https://guides.hexlet.io/assets/images/hosting/servers.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Что такое домен и хостинг?</title><link href="https://guides.hexlet.io/hosting/" rel="alternate" type="text/html" title="Что такое домен и хостинг?" /><published>2021-01-18T00:00:00+00:00</published><updated>2021-01-18T00:00:00+00:00</updated><id>https://guides.hexlet.io/hosting</id><content type="html" xml:base="https://guides.hexlet.io/hosting/">&lt;h2 id=&quot;доменное-имя-домен&quot;&gt;Доменное имя (домен)&lt;/h2&gt;

&lt;p&gt;Когда интернет только зарождался, у сайтов не было доменных имён. Для обращения к сайту использовались прямые IP-адреса машин (серверов), например, 10.132.234.4 (вместо понятного hexlet.io). Довольно быстро стало понятно, что это слишком сложно для запоминания. К тому же адреса могли меняться. Нужно было что-то вроде записной книжки для адресов.&lt;/p&gt;

&lt;p&gt;Первым решением стал специальный файл &lt;em&gt;hosts&lt;/em&gt;, расположенный на каждой машине, с которой происходил доступ к сайтам. Он содержит сопоставление между IP-адресом и именем, удобным для запоминания. Этот файл существует до сих пор и часто используется программистами во время разработки. Формат файла:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;# Формат файла: &amp;lt;ip-адрес&amp;gt; &amp;lt;имена сайта&amp;gt;
34.117.253.138 hexlet.io
172.10.11.200 facebook.com m.facebook.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Когда происходит запрос по адресу, например, hexlet.io, то сначала проверяется файл &lt;em&gt;hosts&lt;/em&gt;, и если домен найден (как в примере выше), то браузер устанавливает соединение с сервером. В нашем примере он пойдёт по адресу &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;34.117.253.138&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Пример обращения к DNS с помощью утилиты host&lt;/span&gt;
host hexlet.io
hexlet.io has address 34.117.253.138
hexlet.io mail is handled by 10 alt4.aspmx.l.google.com.
hexlet.io mail is handled by 1 aspmx.l.google.com.
hexlet.io mail is handled by 10 alt3.aspmx.l.google.com.
hexlet.io mail is handled by 5 alt1.aspmx.l.google.com.
hexlet.io mail is handled by 5 alt2.aspmx.l.google.com.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Такой подход оказался очень неэффективен. В каждой подсети использовался собственный файл hosts, который рассылался на все компьютеры, входящие в подсеть. Кроме того, если появляется новый сайт, то всех нужно оповестить. Да и самих сайтов становилось слишком много. Для решения этих проблем создали Domain Name System (DNS). Основное предназначение этой системы заключается в сопоставлении имени домена конкретному IP-адресу, на котором находится сайт. Другими словами, любой сервис может обратиться к DNS и спросить «какой IP-адрес у домена hexlet.io?».&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/hosting/dns.png&quot; alt=&quot;Как работает DNS&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Важно понимать, что DNS — это именно служба, а не конкретный сервер. Так как весь интернет зависит от стабильности работы этой системы, то в неё входит множество серверов по всему миру. Кроме того, DNS устроена таким образом, что нет центральной организации, управляющей этими серверами. Подробнее о DNS прочитайте в &lt;a href=&quot;https://guides.hexlet.io/dns/&quot;&gt;нашем гайде&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;хостинг&quot;&gt;Хостинг&lt;/h2&gt;

&lt;p&gt;Интернет — это глобальная сеть, объединяющая огромное число устройств. К устройствам относятся далеко не только стационарные компьютеры и ноутбуки, но также и мобильные устройства, камеры, различные электронные и бытовые приборы. Хотя все эти устройства совершенно разные, они без проблем общаются друг с другом с помощью единого языка. Таким языком в мире машин стал стек протоколов &lt;a href=&quot;https://ru.wikipedia.org/wiki/TCP/IP&quot;&gt;TCP/IP&lt;/a&gt;. Не вдаваясь в детали, скажем, что протокол — это правила, по которым происходит общение. При этом природа общающихся устройств не важна.&lt;/p&gt;

&lt;p&gt;Главным элементом в TCP/IP является IP-адрес. В версии IPv4 он выглядит так: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.123.23.1&lt;/code&gt;. Четыре числа, разделённые точкой. У всех устройств, подключенных к сети напрямую, этот адрес уникальный. Фактически, любой запрос в интернете всегда обращается к какому-то IP-адресу, даже если вы этого не видите.&lt;/p&gt;

&lt;p&gt;Среди компьютеров, подключённых к интернету, выделяется класс машин, которые выполняют роль серверов. Эти сервера, как правило, располагаются у хостеров, и именно они обслуживают многочисленные интернет сайты.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/hosting/servers.png&quot; alt=&quot;Серверные стойки&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Хостер — это компания, предоставляющая услугу, называемую хостинг, то есть ресурсы для размещения и обслуживания сайта в интернете. Хостинг бывает очень разным, начиная от уже полностью готовой среды, в которую заливается код сайта, до железных серверов, которыми можно и нужно управлять самостоятельно.&lt;/p&gt;

&lt;p&gt;Работает это обычно так: после регистрации на сайте хостера выбирается тариф, привязывается банковская карточка, и с вас списывается ежемесячная плата за обслуживание и дополнительные услуги. Взамен вы получаете доступ к вашим ресурсам, например, IP-адрес и пару логин/пароль для ssh- или ftp-доступа.&lt;/p&gt;

&lt;p&gt;Однако есть и бесплатные хостинги, требующие только базовых знаний веб-разработки. Чтобы разместить свою страницу в интернете может быть достаточно возможностей бесплатного Github Pages и одной HTML-страницы. Там же можно получить домен третьего уровня или привязать собственный. Подробнее это рассматривается в наших профессиях в уроке &lt;a href=&quot;https://ru.hexlet.io/courses/layout-designer-basics/lessons/publication/theory_unit&quot;&gt;Публикация в интернете&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;виды-хостингов-on-prem-iaas-paas-saas&quot;&gt;Виды хостингов: On-Prem, IaaS, PaaS, SaaS&lt;/h3&gt;

&lt;p&gt;Вы можете использовать старый компьютер, как собственный хостинг, но придётся самостоятельно обеспечивать его постоянную доступность в интернете, защиту от атак и обновление софта. Такое решение будет называться On-Premises. Вместо рукопашки можно воспользоваться решениями “as Service”:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;IaaS — Infrastructure as a Service, инфраструктура как услуга;&lt;/li&gt;
  &lt;li&gt;PaaS — Platform as a Service, платформа как услуга;&lt;/li&gt;
  &lt;li&gt;SaaS — Software as a Service, программное обеспечение как услуга.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Каждый термин означает разный уровень ответственности. В случае с &lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt; от вас требуется только написать HTML и загрузить его в сервис, остальное решается через интерфейс (панель управления), а вся “магия” происходит на стороне сервиса. Это решение SaaS.&lt;/p&gt;

&lt;p&gt;Одно из популярных решений PaaS является &lt;a href=&quot;https://www.heroku.com/&quot;&gt;Heroku&lt;/a&gt;, предоставляющая множество удобных бесплатных инструментов. Практический навык работы с Heroku студенты получают при работе над 4-м проектом в наших профессиях.&lt;/p&gt;

&lt;p&gt;А среди популярных решений IaaS — это &lt;a href=&quot;https://aws.amazon.com/&quot;&gt;Amazon Web Services&lt;/a&gt;. Примечательно, что Heroku использует AWS для размещения ваших ресурсов, то есть выступает посредником, упрощая многие процедуры управления серверами.&lt;/p&gt;

&lt;p&gt;Популярна визуализация этих решений на примере приготовления пиццы, где On-Prem требует наличия и ингредиентов, и инструментов, а SaaS представлен пиццерией, куда вы приходите чтобы съесть пиццу:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/hosting/pizza-as-service.png&quot; alt=&quot;Пицца as service&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;заключение&quot;&gt;Заключение&lt;/h2&gt;

&lt;p&gt;Итак, чтобы создать собственный сайт, вам понадобится домен, хостинг и курсы программирования. Выдачей доменов занимаются организации, именуемые регистраторами. На их сайте вы можете подобрать незанятый домен и оплатить его. После этого каждый год необходимо продление, иначе он вновь станет свободным, и его смогут купить другие. Затем, прямо там же у регистратора, вы можете настроить DNS, например, указать адрес вашего хостинга (в реальности все чуть сложнее, сначала надо указать NS-сервера), на котором находится сайт. Спустя примерно сутки ваш сайт начнёт открываться. Такой срок связан с тем, что информация о новой связке домен-адрес должна распространиться по всем DNS серверам по всему миру. Такая же история происходит и при изменении IP-адреса. Процесс может занять до суток.&lt;/p&gt;

&lt;p&gt;Хостинг может быть простым и бесплатным, а может быть платным и требующим специальных знаний и навыков администрирования. Можно начать с размещения на бесплатном хостинге с бесплатным доменом. Но не следует путать регистраторов доменных имён и хостеров. Часто хостеры выступают как посредники и предлагают купить домены через себя, но, в общем случае, регистраторы — это отдельные компании, которые никак не связаны с хостингом.&lt;/p&gt;

&lt;p&gt;А получить все необходимые навыки программирования и работы с веб-приложениями можно с нашими наставниками в одной из профессий: https://ru.hexlet.io/professions&lt;/p&gt;</content><author><name>Кирилл Мокевнин</name></author><summary type="html">Доменное имя (домен)</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://guides.hexlet.io/assets/images/hosting/servers.png" /><media:content medium="image" url="https://guides.hexlet.io/assets/images/hosting/servers.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Что такое логирование?</title><link href="https://guides.hexlet.io/logging/" rel="alternate" type="text/html" title="Что такое логирование?" /><published>2021-01-18T00:00:00+00:00</published><updated>2021-01-18T00:00:00+00:00</updated><id>https://guides.hexlet.io/logging</id><content type="html" xml:base="https://guides.hexlet.io/logging/">&lt;p&gt;Известно, что программисты проводят много времени, отлаживая свои программы, пытаясь разобраться, почему они не работают — или работают неправильно. Когда говорят про отладку, обычно подразумевают либо отладочную печать, либо использование специальных программ – дебагеров. С их помощью отслеживается выполнение кода по шагам, во время которого видно, как меняется содержимое переменных. Эти способы хорошо работают в небольших программах, но в реальных приложениях быстро становятся неэффективными.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/logging/debugger.png&quot; alt=&quot;Дебагер JavaScript в WebStorm&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;сложность-реальных-приложений&quot;&gt;Сложность реальных приложений&lt;/h2&gt;

&lt;p&gt;Возьмем для примера типичный сайт. Что он в себя включает?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://guides.hexlet.io/dns/&quot;&gt;DNS&lt;/a&gt;. Система трансляции имени сайта в ip-адрес сервера.&lt;/li&gt;
  &lt;li&gt;Веб-сервер. Программа, обслуживающая входящие запросы, перенаправляет их в код приложения и забирает от приложения данные для пользователей.&lt;/li&gt;
  &lt;li&gt;Физический сервер (или виртуальный) с его окружением. Включает в себя операционную систему, установленные и запущенные обслуживающие программы, например, мониторинг.&lt;/li&gt;
  &lt;li&gt;База данных. Внешнее хранилище, с которым связывается код приложения и обменивается информацией.&lt;/li&gt;
  &lt;li&gt;Само приложение. Помимо кода, который пишут программисты, приложение включает в себя сотни тысяч и миллионы строк кода сторонних библиотек. Кроме этого, код работает внутри фреймворка, у которого свои собственные правила обработки входящих запросов.&lt;/li&gt;
  &lt;li&gt;Фронтенд часть. Код, который выполняется в браузере пользователя. И системы сборки для разработки, например, &lt;a href=&quot;https://guides.hexlet.io/webpack/&quot;&gt;Webpack&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;И это только самый простой случай. Реальность же значительно сложнее: множество разноплановых серверов, системы кеширования (ускорения доступа), асинхронный код, очереди, внешние сервисы, облачные сервисы. Все это выглядит как многослойный пирог, внутри которого где-то работает нами написанный код. И этот код составляет лишь небольшую часть всего происходящего. Как в такой ситуации понять, на каком этапе был сбой, или все пошло не по плану? Для этого, как минимум, нужно определить, в каком слое произошла ошибка. Но даже это не самое сложное. Об ошибках в работающем приложении узнают не сразу, а уже потом, — когда ошибка случилась и, иногда, больше не воспроизводится.&lt;/p&gt;

&lt;h2 id=&quot;логирование&quot;&gt;Логирование&lt;/h2&gt;

&lt;p&gt;И для всего этого многообразия систем существует единое решение — логирование. В простейшем случае логирование сводится к файлу на диске, куда разные программы записывают (логируют) свои действия во время работы. Такой файл называют логом или журналом. Как правило, внутри лога одна строчка соответствует одному действию.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Формат: ip-address / date / HTTP-method / uri / response code / body size &lt;/span&gt;
173.245.52.110 - &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;19/Jan/2021:01:54:20 +0000] &lt;span class=&quot;s2&quot;&gt;&quot;GET /my HTTP/1.1&quot;&lt;/span&gt; 200 46018
108.162.219.13 - &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;19/Jan/2021:01:54:20 +0000] &lt;span class=&quot;s2&quot;&gt;&quot;GET /sockjs-node/244/gdt1vvwa/websocket HTTP/1.1&quot;&lt;/span&gt; 0 0
162.158.62.12 - &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;19/Jan/2021:01:54:20 +0000] &lt;span class=&quot;s2&quot;&gt;&quot;GET /packs/css/application.css HTTP/1.1&quot;&lt;/span&gt; 304 0
162.158.62.84 - &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;19/Jan/2021:01:54:20 +0000] &lt;span class=&quot;s2&quot;&gt;&quot;GET /packs/js/runtime-eb0a99abbe8cf813f110.js HTTP/1.1&quot;&lt;/span&gt; 304 0
108.162.219.111 - &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;19/Jan/2021:01:54:20 +0000] &lt;span class=&quot;s2&quot;&gt;&quot;GET /packs/js/application-2cba5619945c4e5946f1.js HTTP/1.1&quot;&lt;/span&gt; 304 0
108.162.219.21 - &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;19/Jan/2021:01:54:20 +0000] &lt;span class=&quot;s2&quot;&gt;&quot;GET /packs/js/0564a7b5d773bab52e53.js HTTP/1.1&quot;&lt;/span&gt; 304 0
108.162.219.243 - &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;19/Jan/2021:01:54:20 +0000] &lt;span class=&quot;s2&quot;&gt;&quot;GET /packs/js/6fb7e908211839fac06e.js HTTP/1.1&quot;&lt;/span&gt; 304 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Выше небольшой кусок лога веб-сервера Хекслета. Из него видно ip-адрес, с которого выполнялся запрос на страницу и какие ресурсы загружались, метод HTTP, ответ бекенда (кода) и размер тела ответа в HTTP. Очень важно наличие даты. Благодаря ей всегда можно найти лог за конкретный период, например на то время, когда возникла ошибка. Для этого логи &lt;a href=&quot;https://ru.hexlet.io/courses/cli-basics/lessons/grep/theory_unit&quot;&gt;грепают&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Выведет 4 минуты логов за 31 марта 2020 года с 19:31 по 19:35&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;31/Mar/2020:19:3[1-5]&quot;&lt;/span&gt; access.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Когда программисты только начинают свой путь, они, часто не зная причину ошибки, опускают руки и говорят «я не знаю, что случилось, и что делать». Опытный же разработчик всегда первым делом говорит «а что в логах?». Анализировать логи — один из базовых навыков в разработке. В любой непонятной ситуации нужно смотреть логи. Логи пишут все программы без исключения, но делают это по-разному и в разные места. Чтобы точно узнать, куда и как, нужно идти в документацию конкретной программы и читать соответствующий раздел документации. Вот несколько примеров:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://guides.rubyonrails.org/debugging_rails_applications.html#the-logger&quot;&gt;Ruby On Rails (Ruby)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.djangoproject.com/en/3.1/topics/logging/&quot;&gt;Django (Python)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://laravel.com/docs/8.x/logging&quot;&gt;Laravel (PHP)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.1.18.RELEASE/reference/html/boot-features-logging.html&quot;&gt;Spring Boot (Java)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.fastify.io/docs/v2.0.x/Logging/&quot;&gt;Fastify (Node.js)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Многие программы логируют прямо в консоль, например Webpack показывает процесс и результаты сборки:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Сюда же выводятся ошибки, если они были&lt;/span&gt;
｢wds｣: Project is running at http://hexletdev4.com/
｢wds｣: webpack output is served from /packs/
｢wds｣: Content not from webpack is served from /root/hexlet/public/packs
｢wds｣: 404s will fallback to /index.html
｢wdm｣: assets by chunk 10.8 MiB &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;auxiliary name: application&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 115 assets
sets by path js/ 13.8 MiB
assets by path js/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.js 13.8 MiB 52 assets
assets by path js/pages/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.js 5.1 KiB
  asset js/pages/da223d3affe56711f31f.js 2.6 KiB &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;emitted] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;immutable] &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;name: pages/my_learning&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 1 related asset
  asset js/pages/04adacfdd660803b19f1.js 2.5 KiB &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;emitted] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;immutable] &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;name: pages/referral&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 1 related asset
sets by chunk 9.14 KiB &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;auxiliary &lt;span class=&quot;nb&quot;&gt;id &lt;/span&gt;hint: vendors&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Во фронтенде файлов нет, поэтому логируют либо прямо в консоль, либо к себе в бекенды (что сложно), либо в специализированные сервисы, такие как &lt;a href=&quot;https://logrocket.com/&quot;&gt;LogRocket&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;уровни-логирования&quot;&gt;Уровни логирования&lt;/h2&gt;

&lt;p&gt;Чем больше информации выводится в логах, тем лучше и проще отладка, но когда данных слишком много, то в них тяжело искать нужное. В особо сложных случаях логи могут генерироваться с огромной скоростью и в гигантских размерах. Работать в такой ситуации нелегко. Чтобы как-то сгладить ситуацию, системы логирования вводят разные уровни. Обычно это:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;debug&lt;/li&gt;
  &lt;li&gt;info&lt;/li&gt;
  &lt;li&gt;warning&lt;/li&gt;
  &lt;li&gt;error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Поддержка уровней осуществляется двумя способами. Во-первых, внутри самой программы расставляют вызовы библиотеки логирования в соответствии с уровнями. Если произошла ошибка, то логируем как &lt;em&gt;error&lt;/em&gt;, если это отладочная информация, которая не нужна в обычной ситуации, то уровень &lt;em&gt;debug&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Пример логирования внутри программы&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Логер: https://github.com/pinojs/pino&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;buildLogger&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;pino&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;logger&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;buildLogger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* возможная конфигурация */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;тут что то полезное&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Во-вторых, во время запуска программы указывается уровень логирования, необходимый в конкретной ситуации. По умолчанию используется уровень &lt;em&gt;info&lt;/em&gt;, который используется для описания каких-то ключевых и важных вещей. При таком уровне будут выводиться и &lt;em&gt;warning&lt;/em&gt;, и &lt;em&gt;error&lt;/em&gt;. Если поставить уровень &lt;em&gt;error&lt;/em&gt;, то будут выводиться только ошибки. А если &lt;em&gt;debug&lt;/em&gt;, то мы получим лог, максимально наполненный данными. Обычно &lt;em&gt;debug&lt;/em&gt; приводит к многократному росту выводимой информации.&lt;/p&gt;

&lt;p&gt;Уровни логирования, обычно, выставляются через переменную окружения во время запуска программы. Например, так:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# https://github.com/fastify/fastify-cli#options&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;FASTIFY_LOG_LEVEL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;debug fastify-server.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Существует и другой подход, основанный не на уровнях, а на пространствах имен. Этот подход получил широкое распространение в JS-среде, и является там основным. Фактически, он построен вокруг одной единственной библиотеки &lt;a href=&quot;https://github.com/visionmedia/debug&quot;&gt;debug&lt;/a&gt; для логирования, которой пронизаны практически все JavaScript-библиотеки как на фронтенде, так и на бекенде.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/logging/debug.png&quot; alt=&quot;Библиотека debug в JavaScript&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Принцип работы здесь такой. Под нужную ситуацию создается специализированная функция логирования с указанием пространства имен, которая затем используется для всех событий одного процесса. В итоге библиотека позволяет легко отфильтровать только нужные записи, соответствующие нужному пространству.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;debug&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Пространство имен http&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;logHttp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;logSomethingElse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;another-namespace&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Где-то в коде&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;logHttp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* информация о http запросе */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Запуск с нужным пространством:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;DEBUG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http server.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/logging/debug-http.png&quot; alt=&quot;Библиотека debug для логирования http в JavaScript&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ротация-логов&quot;&gt;Ротация логов&lt;/h2&gt;

&lt;p&gt;Со временем количество логов становится большим, и с ними нужно что-то делать. Для этого используется ротация логов. Иногда за это отвечает сама программа, но чаще — внешнее приложение, задачей которого является чистка. Эта программа по необходимости разбивает логи на более мелкие файлы, сжимает, перемещает и, если нужно, удаляет. Подобная система встроена в любую операционную систему для работы с логами самой системы и внешних программ, которые могут встраиваться в нее.&lt;/p&gt;

&lt;p&gt;С веб-сайтами все еще сложнее. Даже на небольших проектах используется несколько серверов, на каждом из которых свои логи. А в крупных проектах тысячи серверов. Для управления такими системы созданы специализированные программы, которые следят за логами на всех машинах, скачивают их, складывают в заточенные под логи базы данных и предоставляют удобный способ поиска по ним.&lt;/p&gt;

&lt;p&gt;Здесь тоже есть несколько путей. Можно воспользоваться готовыми решениями, такими как &lt;a href=&quot;https://docs.datadoghq.com/logs/&quot;&gt;DataDog Logging&lt;/a&gt;, либо устанавливать и настраивать все самостоятельно через, например, &lt;a href=&quot;https://www.elastic.co/elastic-stack&quot;&gt;ELK Stack&lt;/a&gt;&lt;/p&gt;</content><author><name>Кирилл Мокевнин</name></author><summary type="html">Известно, что программисты проводят много времени, отлаживая свои программы, пытаясь разобраться, почему они не работают — или работают неправильно. Когда говорят про отладку, обычно подразумевают либо отладочную печать, либо использование специальных программ – дебагеров. С их помощью отслеживается выполнение кода по шагам, во время которого видно, как меняется содержимое переменных. Эти способы хорошо работают в небольших программах, но в реальных приложениях быстро становятся неэффективными.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://guides.hexlet.io/assets/images/logging/cover.png" /><media:content medium="image" url="https://guides.hexlet.io/assets/images/logging/cover.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Что такое компилятор?</title><link href="https://guides.hexlet.io/compiler/" rel="alternate" type="text/html" title="Что такое компилятор?" /><published>2020-10-28T00:00:00+00:00</published><updated>2020-10-28T00:00:00+00:00</updated><id>https://guides.hexlet.io/compiler</id><content type="html" xml:base="https://guides.hexlet.io/compiler/">&lt;p&gt;В этом гайде вы узнаете о том, что такое компилятор и как он работает. Мы разберем этапы компиляции и от чего зависит выбор подходящего компилятора. Этот материал поможет лучше понять, как компьютер выполняет программный код и почему иногда код не компилируется.&lt;/p&gt;

&lt;h2 id=&quot;зачем-нужен-компилятор&quot;&gt;Зачем нужен компилятор?&lt;/h2&gt;

&lt;p&gt;Процессор — самая важная часть компьютера. Он обрабатывает информацию, выполняет команды пользователя и следит за работой всех подключенных устройств. Но процессор может разобрать только машинный код — набор 0 и 1, которые записаны в определённом порядке.&lt;/p&gt;

&lt;p&gt;Почему именно 0 и 1? В процессор поступают электрические сигналы. Сильный сигнал обозначается цифрой 1, а слабый — 0. Набор таких цифр обозначает какую-то команду. Процессор ее распознает и выполняет.&lt;/p&gt;

&lt;p&gt;Программы для первых компьютеров выглядели как огромные наборы 0 и 1. Чтобы записать такую программу, инженеры пользовались гибкими картонными карточками — перфокартами. Цифры на перфокарте записывались поочередно, в несколько строк. Чтобы записать 1, программист делал отверстие в карте. Места без отверстия обозначали 0.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/compiler/card.png&quot; alt=&quot;Изображение перфокарты&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Компьютер считывал перфокарту специальным устройством и выполнял записанную команду. Для одной программы составляли сотни перфокарт.&lt;/p&gt;

&lt;p&gt;Писать их было долго и сложно, поэтому инженеры стали создавать языки программирования, обозначая команды словами и знаками. Для того, чтобы процессор понимал, какие команды записаны в программе, программисты создали &lt;strong&gt;компилятор&lt;/strong&gt; — программу, которая преобразует программный код в машинный.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/compiler/compiler.jpg&quot; alt=&quot;Схема преобразования програмного кода в бинарный&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;как-работает-компилятор&quot;&gt;Как работает компилятор?&lt;/h2&gt;

&lt;p&gt;Преобразование программного кода в машинный называется &lt;em&gt;компиляцией&lt;/em&gt;. Компиляция только преобразует код. Она не запускает его на исполнение. В этот момент он “статически” (то есть без запуска) транслируется в машинный код. Это сложный процесс, в котором сначала текст программы разбирается на части и анализируется, а затем генерируется код, понятный процессору.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/compiler/compilation_steps.jpg&quot; alt=&quot;Этапы компиляции&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Разберём этапы компиляции на примере вычисления периметра прямоугольника:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt; 
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Width of the rectangle - %4.1f&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// =&amp;gt; Width of the rectangle - 2.5&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Length of the rectangle - %4.1f&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// =&amp;gt; Length of the rectangle - 5.0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Perimeter of the rectangle is %4.1f&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// =&amp;gt; Perimeter of the rectangle is 15.0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;После запуска программы компилятору нужно определить, какие команды в ней записаны. Сначала компилятор разделяет программу на слова и знаки — &lt;em&gt;токены&lt;/em&gt;, и записывает их в список. Такой процесс называется &lt;strong&gt;лексическим анализом&lt;/strong&gt;. Его главная задача — получить токены.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;# include &amp;lt;iostream&amp;gt; int main ( ) { double a = 2.5 , b = 5 , P ;  P = 2 * ( a + b ) ; printf ( &quot; Width of the rectangle - % 4.1 f &quot; , a ) ; printf ( &quot; \ n Length of the rectangle - % 4.1 f &quot; , b ) ; printf ( &quot; \ n Perimeter of the rectangle is % 4.1 f &quot; ,   P ) ; return 0 ; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Затем компилятор читает список и ищет токен-операторы. Это могут быть оператор присваивания(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;=&lt;/code&gt;), арифметические операторы(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/&lt;/code&gt;), оператор вывода(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf()&lt;/code&gt;) и другие операторы языка программирования. Такие операторы работают с числами, текстом и переменными.&lt;/p&gt;

&lt;p&gt;Компилятор должен понять, какие токены в списке связаны с токен-оператором. Чтобы сделать это правильно, для каждого оператора строится специальная структура — &lt;strong&gt;логическое дерево&lt;/strong&gt; или &lt;strong&gt;дерево разбора&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Так операция &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P = 2*(a + b)&lt;/code&gt; будет преобразована в логическое дерево:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/compiler/parse_tree.jpg&quot; alt=&quot;Дерево разбора&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Теперь каждое дерево нужно разобрать на команды, и каждую команду преобразовать в &lt;strong&gt;машинный код&lt;/strong&gt;. 
Компилятор начинает читать дерево снизу вверх и составляет список команд:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Взять переменную &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;, взять переменную &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;, сложить их&lt;/li&gt;
  &lt;li&gt;Взять результат сложения, взять число &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; и найти их произведение&lt;/li&gt;
  &lt;li&gt;Результат произведения присвоить (записать) в переменную &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Компилятор еще раз проверяет команды, находит ошибки и старается улучшить код. При успешном завершении этого этапа, компилятор переводит каждую команду в набор 0 и 1. Наборы записываются в файл, который сможет прочитать и выполнить процессор.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;10111011 00010001 00000001 10111001 00001101 00000000 10110100 00001110 10001010 00000111 01000011 11001101 00010000 11100010 11111001 11001101 00100000 01001000 01100101 01101100 01101100 01101111 00101100 00100000 01010111 01101111 01110010 01101100 01100100 00100001
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;на-чем-написан-компилятор&quot;&gt;На чем написан компилятор?&lt;/h2&gt;

&lt;p&gt;В 1950-е годы группа разработчиков IBM под руководством Джона Бэкуса разработала первый высокоуровневый язык программирования &lt;a href=&quot;https://ru.wikipedia.org/wiki/Фортран&quot;&gt;Fortran&lt;/a&gt;, который позволил писать программы на понятном человеку языке. Помимо языка, инженеры работали и над компилятором. Он представлял собой программу с набором исполняемых команд, которая могла компилировать другие программы на Fortran, в том числе и улучшенную версию себя.&lt;/p&gt;

&lt;p&gt;В дальнейшем язык Fortran и его компилятор использовали, чтобы написать компиляторы для новых языков программирования. Такой подход используют программисты и в настоящее время. 
Писать машинный код долго и неудобно. К тому же, для современных процессоров он может отличаться. Придется писать несколько версий одного и того же компилятора для разных компьютеров. Быстрее и проще написать компилятор на существующем языке программирования. Для этого разработчики выбирают удобный язык и пишут на нем первую версию своего компилятора. Он будет более универсальным для компьютеров и легко скомпилирует улучшенную версию себя.
&lt;img src=&quot;/assets/images/compiler/create_compiler.jpg&quot; alt=&quot;Этапы создания компилятора&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;какие-бывают-компиляторы&quot;&gt;Какие бывают компиляторы?&lt;/h2&gt;

&lt;p&gt;Ни один компилируемый язык программирования не обходится без компилятора. Некоторые компиляторы работают с несколькими языками программирования. Но программист должен учитывать еще и параметры компьютера, на котором программа будет запускаться.&lt;/p&gt;

&lt;p&gt;Дело в том, что современные процессоры отличаются друг от друга устройством, поэтому машинный код для одного процессора будет понятен, а для другого нет. Это касается и операционных систем: одна и та же программа будет работать на Windows, но не запустится на Linux или MacOS. Поэтому нужно пользоваться тем компилятором, который работает с нужным процессором и операционной системой.&lt;/p&gt;

&lt;p&gt;Если программа будет работать на нескольких операционных системах, то нужен кросс-компилятор — компилятор, который преобразует универсальный машинный код. Например, GNU Compiler Collection(сокращенно GCC) поддерживает C++, Objective-C, Java, Фортран, Ada, Go и поддерживает разную архитектуру процессоров.&lt;/p&gt;

&lt;p&gt;Начинающие программисты даже не знают о наличии компилятора на компьютере. Они пишут программы в интегрированной среде разработки, в которую встроен компилятор, а иногда и не один. В этом случае, выбор компилятора делает среда, а не программист. Например, MS Visual Studio поддерживает компиляторы для операционных систем Windows, Linux, Android. Выбирая тип проекта, Visual Studio определяет процессор и операционную систему компьютера, и после этого выбирает подходящий компилятор.&lt;/p&gt;

&lt;h2 id=&quot;какие-ошибки-может-определить-компилятор&quot;&gt;Какие ошибки может определить компилятор?&lt;/h2&gt;

&lt;p&gt;Когда компилятор анализирует текст программы, он проверяет, соответствует ли запись оператора стандартам языка. Если найдено несоответствие, то компилятор выводит об этом информацию пользователю в виде &lt;em&gt;ошибки&lt;/em&gt;. Когда вся программа разобрана, пользователь видит список ошибок, которые есть в коде, и может их исправить. 
Пока программист не исправит ошибки, компилятор не перейдет к следующему этапу — генерации машинного кода для процессора.
Чаще всего компилятор показывает пользователю:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ошибки объявления переменных или отсутствие их начальных значений&lt;/li&gt;
  &lt;li&gt;ошибки несоответствия типов&lt;/li&gt;
  &lt;li&gt;ошибки неправильной записи операторов и функций&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Иногда компилятор определяет код, который при выполнении дает неправильный результат. Но преобразовать такую программу в машинный код все-таки можно. В этом случае компилятор показывает пользователю &lt;em&gt;предупреждение&lt;/em&gt;. Такая реакция компилятора больше похожа на рекомендации, но на них стоит обратить внимание. Программист сам решает оставить код с предупреждением или изменить программу.
Анализируя текст программы, компилятор не только ищет ошибки, но еще и упрощает ее код. Такой процесс называется оптимизацией.
Во время оптимизации компилятор изменяет программный код, но функции, которые выполняла программа, остаются прежними.&lt;/p&gt;

&lt;h2 id=&quot;выводы-и-рекомендации&quot;&gt;Выводы и рекомендации&lt;/h2&gt;

&lt;p&gt;Компилятор — переводчик между программистом и процессором. Он преобразует текст программы в машинный код, определяет ряд ошибок в программе и оптимизирует ее работу.
Выбирая, где компилировать программу, важно помнить о том, что машинный код для процессоров и операционных систем будет разным, и подобрать правильный компилятор.
Чем точнее компилятор определит команды, тем корректнее и быстрее будет работать программа. Для этого следуйте простым рекомендациям:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;использовать простые, понятные команды;&lt;/li&gt;
  &lt;li&gt;помнить о соответствии типов данных;&lt;/li&gt;
  &lt;li&gt;внимательно набирать код, избегая синтаксических ошибок;&lt;/li&gt;
  &lt;li&gt;избегать повторяющихся действий и бесполезных переменных.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;дополнительные-материалы&quot;&gt;Дополнительные материалы&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ru.wikipedia.org/wiki/Компилятор&quot;&gt;Компилятор&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://habr.com/ru/company/droider/blog/519732/&quot;&gt;ARM против x86: В чем разница между двумя архитектурами процессоров?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Татьяна Федорина</name></author><summary type="html">В этом гайде вы узнаете о том, что такое компилятор и как он работает. Мы разберем этапы компиляции и от чего зависит выбор подходящего компилятора. Этот материал поможет лучше понять, как компьютер выполняет программный код и почему иногда код не компилируется.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://guides.hexlet.io/assets/images/compiler/compiler.jpg" /><media:content medium="image" url="https://guides.hexlet.io/assets/images/compiler/compiler.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Что такое Makefile и как начать его использовать</title><link href="https://guides.hexlet.io/makefile-as-task-runner/" rel="alternate" type="text/html" title="Что такое Makefile и как начать его использовать" /><published>2020-07-30T00:00:00+00:00</published><updated>2020-07-30T00:00:00+00:00</updated><id>https://guides.hexlet.io/makefile-as-task-runner</id><content type="html" xml:base="https://guides.hexlet.io/makefile-as-task-runner/">&lt;h2 id=&quot;введение&quot;&gt;Введение&lt;/h2&gt;

&lt;p&gt;В жизни многих разработчиков найдётся история про первый рабочий день с новым проектом. После клонирования основного репозитория проекта наступает этап, когда приходится вводить множество команд с определёнными флагами и в заданной последовательности. Без описания команд, в большинстве случаев, невозможно понять что происходит, например:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Bash&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;touch&lt;/span&gt; ~/.bash_history
ufw allow 3035/tcp &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;cant configure ufw&apos;&lt;/span&gt;
ufw allow http &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;cant configure ufw&apos;&lt;/span&gt;
docker run &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /root/:/root/ &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /etc:/etc &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /var/run/docker.sock:/var/run/docker.sock &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /var/tmp:/var/tmp &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /tmp:/tmp &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$PWD&lt;/span&gt;:/app &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt; host &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-w&lt;/span&gt; /app &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--env-file&lt;/span&gt; .env &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  ansible ansible-playbook ansible/development.yml &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; ansible/development &lt;span class=&quot;nt&quot;&gt;--limit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;localhost &lt;span class=&quot;nt&quot;&gt;-vv&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-qxF&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;fs.inotify.max_user_watches=524288&apos;&lt;/span&gt; /etc/sysctl.conf &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;fs.inotify.max_user_watches&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;524288 | &lt;span class=&quot;nb&quot;&gt;tee&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; /etc/sysctl.conf &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;cant set max_user_watches&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sysctl &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl daemon-reload &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Эти команды являются лишь частью того, что необходимо выполнить при разворачивании проекта. В приведённом примере видно, что команды сами по себе длинные, содержат много флагов, а значит, их трудно не только запомнить, но и вводить вручную. Постоянно вести документацию становится сложнее с ростом проекта, она неизбежно устаревает, а порог входа для новичков становится выше, ведь уже никто не в состоянии вспомнить всех деталей проекта. Некоторые такие команды необходимо использовать каждый день, и даже не один раз в день.&lt;/p&gt;

&lt;p&gt;Со временем становится понятно, что нужен инструмент, способный объединить в себе подобные команды, предоставить к ним удобные шорткаты (&lt;em&gt;более короткие и простые команды&lt;/em&gt;) и обеспечить самодокументацию проекта. Именно таким инструментом стал &lt;em&gt;Makefile&lt;/em&gt; и утилита &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt;. Этот гайд расскажет, как использование этих инструментов позволит свести процесс разворачивания проекта к нескольким коротким и понятным командам:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Bash&lt;/span&gt;
make setup
make start
make &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;что-такое-make-и-makefile&quot;&gt;Что такое &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt; и &lt;em&gt;Makefile&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Makefile&lt;/em&gt; — это файл, который хранится вместе с кодом в репозитории. Его обычно помещают в корень проекта. Он выступает и как документация, и как исполняемый код. Мейкфайл скрывает за собой детали реализации и раскладывает “по полочкам” команды, а утилита &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt; запускает их из того мейкфайла, который находится в текущей директории.&lt;/p&gt;

&lt;p&gt;Изначально &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt; предназначалась для автоматизации сборки исполняемых программ и библиотек из исходного кода. Она поставлялась по умолчанию в большинство *nix дистрибутивов, что и привело к её широкому распространению и повсеместному использованию. Позже оказалось что данный инструмент удобно использовать и при разработке любых других проектов, потому что процесс в большинстве своём сводится к тем же задачам — автоматизация и сборка приложений.&lt;/p&gt;

&lt;p&gt;Применение мейка в проектах стало стандартом для многих разработчиков, включая крупные проекты. Примеры мейкфайла можно найти у таких проектов, как &lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/master/build/root/Makefile&quot;&gt;Kubernetes&lt;/a&gt;, &lt;a href=&quot;https://github.com/babel/babel/blob/main/Makefile&quot;&gt;Babel&lt;/a&gt;, &lt;a href=&quot;https://github.com/ansible/ansible/blob/devel/Makefile&quot;&gt;Ansible&lt;/a&gt; и, конечно же, повсеместно на &lt;a href=&quot;https://github.com/Hexlet&quot;&gt;Хекслете&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;синтаксис-makefile&quot;&gt;Синтаксис &lt;em&gt;Makefile&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt; запускает цели из &lt;em&gt;Makefile&lt;/em&gt;, которые состоят из команд:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;цель1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; имя цели&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; поддерживается kebab-case и snake_case&lt;/span&gt;
	команда1 &lt;span class=&quot;c&quot;&gt;# для отступа используется табуляция, это важная деталь &lt;/span&gt;
	команда2 &lt;span class=&quot;c&quot;&gt;# команды будут выполняться последовательно и только в случае успеха предыдущей&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Но недостаточно просто начать использовать мейкфайл в проекте. Чтобы получить эффект от его внедрения, понадобится поработать над разделением команд на цели, а целям дать семантически подходящие имена. Поначалу, перенос команд в Makefile может привести к свалке всех команд в одну цель с «размытым» названием:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;up&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; разворачивание и запуск&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; .env.example .env
	&lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;database/database.sqlite
	composer &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
	npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
	php artisan key:generate
	php artisan migrate &lt;span class=&quot;nt&quot;&gt;--seed&lt;/span&gt;
	heroku &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; Procfile.dev &lt;span class=&quot;c&quot;&gt;# запуск проекта&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Здесь происходит сразу несколько действий: создание файла с переменными окружения, подготовка базы данных, генерация ключей, установка зависимостей и запуск проекта. Это невозможно понять из комментариев и названия цели, поэтому будет правильно разделить эти независимые команды на разные цели:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;env-prepare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; создать .env-файл для секретов&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; .env.example .env

&lt;span class=&quot;nl&quot;&gt;sqlite-prepare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; подготовить локальную БД&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;database/database.sqlite

&lt;span class=&quot;nl&quot;&gt;install&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; установить зависимости&lt;/span&gt;
	composer &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
	npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; сгенерировать ключи&lt;/span&gt;
	php artisan key:generate

&lt;span class=&quot;nl&quot;&gt;db-prepare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; загрузить данные в БД&lt;/span&gt;
	php artisan migrate &lt;span class=&quot;nt&quot;&gt;--seed&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; запустить приложение&lt;/span&gt;
	heroku &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; Procfile.dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь, когда команды разбиты на цели, можно отдельно установить зависимости командой &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make install&lt;/code&gt; или запустить приложение через &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make start&lt;/code&gt;. Но остальные цели нужны только при первом разворачивании проекта и выполнять их нужно в определённой последовательности. Говоря языком мейкфайла, цель имеет пререквизиты:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;цель1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;цель2 &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; такой синтаксис указывает на зависимость задач — цель1 зависит от цель2&lt;/span&gt;
	команда2 &lt;span class=&quot;c&quot;&gt;# команда2 выполнится только в случае успеха команды из цель2&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;цель2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	команда1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Задачи будут выполняться только в указанной последовательности и только в случае успеха предыдущей задачи. Значит, можно добавить цель &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setup&lt;/code&gt;, чтобы объединить в себе все необходимые действия:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;env-prepare sqlite-prepare install key db-prepare &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; можно ссылаться на цели&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; описанные ниже&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;env-prepare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; .env.example .env

&lt;span class=&quot;nl&quot;&gt;sqlite-prepare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;database/database.sqlite

&lt;span class=&quot;nl&quot;&gt;install&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	composer &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
	npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	php artisan key:generate

&lt;span class=&quot;nl&quot;&gt;db-prepare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	php artisan migrate &lt;span class=&quot;nt&quot;&gt;--seed&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	heroku &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; Procfile.dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь развернуть и запустить проект достаточно двумя командами:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Bash&lt;/span&gt;
make setup &lt;span class=&quot;c&quot;&gt;# выполнит последовательно: env-prepare sqlite-prepare install key db-prepare&lt;/span&gt;
make start
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Благодаря проделанной работе &lt;em&gt;Makefile&lt;/em&gt;, команды проекта вместе с флагами сведены в &lt;em&gt;Makefile&lt;/em&gt;. Он обеспечивает правильный порядок выполнения и не важно, какие при этом задействованы языки и технологии.&lt;/p&gt;

&lt;h2 id=&quot;продвинутое-использование&quot;&gt;Продвинутое использование&lt;/h2&gt;

&lt;h3 id=&quot;фальшивая-цель&quot;&gt;Фальшивая цель&lt;/h3&gt;

&lt;p&gt;Использование &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt; в проекте однажды может привести к появлению ошибки &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make: &amp;lt;имя-цели&amp;gt; is up to date.&lt;/code&gt;, хотя всё написано правильно. Зачастую, её появление связано с наличием каталога или файла, совпадающего с именем цели. Например:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; цель в мейкфайле&lt;/span&gt;
	php artisan &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls
&lt;/span&gt;Makefile
&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# в файловой системе находится каталог с именем, как у цели в мейкфайле&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# попытка запустить тесты&lt;/span&gt;
make: &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; is up to date.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Как уже говорилось ранее, изначально &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt; предназначалась для сборок из исходного кода. Поэтому она ищет каталог или файл с указанным именем, и пытается собрать из него проект. Чтобы изменить это поведение, необходимо в конце мейкфайла добавить &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.PHONY&lt;/code&gt; указатель на цель:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	php artisan &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;.PHONY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
✓ All tests passed!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;последовательный-запуск-команд-и-игнорирование-ошибок&quot;&gt;Последовательный запуск команд и игнорирование ошибок&lt;/h3&gt;

&lt;p&gt;Запуск команд можно производить по одной: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make setup&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make start&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make test&lt;/code&gt; или указывать цепочкой через пробел: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make setup start test&lt;/code&gt;. Последний способ работает как зависимость между задачами, но без описания её в мейкфайле. Сложности могут возникнуть, если одна из команд возвращает ошибку, которую нужно игнорировать. В примерах ранее такой командой было создание .env-файла при разворачивании проекта:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;env-prepare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; .env.example .env &lt;span class=&quot;c&quot;&gt;# если файл уже создан, то повторный запуск этой команды вернёт ошибку&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Самый простой (&lt;em&gt;но не единственный&lt;/em&gt;) способ «заглушить» ошибку — это сделать логическое ИЛИ прямо в мейкфайле:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;env-prepare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; .env.example .env &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# теперь любой исход выполнения команды будет считаться успешным&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Добавлять такие хаки стоит с осторожностью, чтобы не «выстрелить себе в ногу» в более сложных случаях.&lt;/p&gt;

&lt;h3 id=&quot;переменные&quot;&gt;Переменные&lt;/h3&gt;

&lt;p&gt;Зачастую в команды подставляют параметры для конфигурации, указания путей, переменные окружения и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt; тоже позволяет этим управлять. Переменные можно прописать прямо в команде внутри мейкфайла и передавать их при вызове:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello, &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$(HELLO)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;!&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make say &lt;span class=&quot;nv&quot;&gt;HELLO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;World
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello, World!&quot;&lt;/span&gt;
Hello, World!

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make say &lt;span class=&quot;nv&quot;&gt;HELLO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Kitty
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello, Kitty!&quot;&lt;/span&gt;
Hello, Kitty!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Переменные могут быть необязательными и содержать значение по умолчанию. Обычно их объявляют в начале мейкфайла.&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;HELLO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?=&lt;/span&gt;World &lt;span class=&quot;c&quot;&gt;# знак вопроса указывает, что переменная опциональна. Значение после присвоения можно не указывать.&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello, &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$(HELLO)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;!&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make say
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello, World!&quot;&lt;/span&gt;
Hello, World!

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make say &lt;span class=&quot;nv&quot;&gt;HELLO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Kitty
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello, Kitty!&quot;&lt;/span&gt;
Hello, Kitty!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Некоторые переменные в &lt;em&gt;Makefile&lt;/em&gt; имеют названия отличные от системных. Например, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$PWD&lt;/code&gt; называется &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$CURDIR&lt;/code&gt; в &lt;a href=&quot;https://github.com/hexlet-basics/hexlet_basics/blob/3f4635bf629e2676efe547c9a01c22a2573eaebd/Makefile#L35-L39&quot;&gt;мейкфайле&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;project-env-generate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	docker run &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;RUNNER_PLAYBOOK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ansible/development.yml &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(CURDIR)&lt;/span&gt;/ansible/development:/runner/inventory &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$(CURDIR)&lt;/span&gt; - то же самое, что &lt;span class=&quot;nv&quot;&gt;$PWD&lt;/span&gt; в терминале
		&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;v &lt;span class=&quot;nv&quot;&gt;$(CURDIR)&lt;/span&gt;:/runner/project &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
		ansible/ansible-runner
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;заключение&quot;&gt;Заключение&lt;/h2&gt;

&lt;p&gt;В рамках данного гайда было рассказано об основных возможностях &lt;em&gt;Makefile&lt;/em&gt; и утилиты &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt;. Более плотное знакомство с данным инструментом откроет множество других его полезных возможностей: условия, циклы, подключение файлов. В компаниях, где имеется множество проектов, написанных разными командами в разное время, мейкфайл станет отличным подспорьем в стандартизации типовых команд: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setup start test deploy ...&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Возможность описывать в мейкфале последовательно многострочные команды позволяет использовать его как «универсальный клей» между менеджерами языков и другими утилитами. Широкая распространённость этого инструмента и общая простота позволяют внедрить его в свой проект достаточно легко, без необходимости доработок. Но мейкфайл может быть по-настоящему большим и сложным, это можно увидеть на примере реальных проектов:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/hexlet-codebattle/codebattle/blob/master/Makefile&quot;&gt;Codebattle&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/babel/babel/blob/main/Makefile&quot;&gt;Babel&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/master/build/root/Makefile&quot;&gt;Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;дополнительные-материалы&quot;&gt;Дополнительные материалы&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ru.makefile.site/&quot;&gt;Руководство по современному Make&lt;/a&gt; — «выжимка» из документации на русском языке;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=pK9mF5aK05Q&quot;&gt;Утилита make: полезный универсальный инструмент программиста&lt;/a&gt; — видео-версия данного гайда.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Мейкфайлы, использованные при составлении гайда:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Hexlet/hexlet-sicp/blob/master/Makefile&quot;&gt;Hexlet SICP&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/hexlet-basics/hexlet_basics/blob/master/Makefile&quot;&gt;Hexlet Basics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Кирилл Мокевнин</name></author><summary type="html">Введение</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://guides.hexlet.io/assets/images/makefile/cover.jpg" /><media:content medium="image" url="https://guides.hexlet.io/assets/images/makefile/cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Что такое “Менеджер версий”</title><link href="https://guides.hexlet.io/version_managers/" rel="alternate" type="text/html" title="Что такое “Менеджер версий”" /><published>2020-06-28T00:00:00+00:00</published><updated>2020-06-28T00:00:00+00:00</updated><id>https://guides.hexlet.io/version_managers</id><content type="html" xml:base="https://guides.hexlet.io/version_managers/">&lt;h2 id=&quot;системная-установка&quot;&gt;Системная установка&lt;/h2&gt;

&lt;p&gt;Для запуска кода на любом языке, необходимо установить его интерпретатор (или компилятор). В разных операционных системах это делается по-разному: где-то используются пакетные менеджеры, например, &lt;em&gt;apt&lt;/em&gt; или &lt;em&gt;yum&lt;/em&gt;, где-то скачивается установщик. Некоторые языки бывают предустановленны сразу, например, Python. На него многое завязано в дистрибутивах линукса.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Ubuntu&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;nodejs &lt;span class=&quot;c&quot;&gt;# установит не самую свежую версию&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Стандартный способ установки работает хорошо только в самом начале, когда происходит первичная настройка. Затем, с течением времени, начинают всплывать разные проблемы. Например, в какой-то момент выходит новая версия языка, которую нужно подключить к проекту. Обычно, должно пройти какое-то время, перед тем, как язык станет доступным для установки через пакетные менеджеры. И здесь либо придется ждать, что не всегда желательно, либо искать другой способ установки. Последнее нередко превращается в серьёзное испытание, с часами гугления и установкой дополнительных библиотек. Все это в конце концов засоряет систему и иногда ломает её.&lt;/p&gt;

&lt;p&gt;Другая серьёзная проблема – установка сразу нескольких версий одного языка. Такое бывает нужно, когда разработчик переключается между разными проектами, требующими разные версии. Насколько часто такое происходит? Крайне часто. Чем дальше в разработку, тем больше вариантов: разные проекты в компании, свои проекты, опенсорс.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Здесь нужно упомянуть, что всё это мало касается тех, кто целиком ушел в Docker и Docker Compose. Однако даже в этом случае, нужны языки для работы с опенсорсом.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;менеджеры-версий&quot;&gt;Менеджеры версий&lt;/h2&gt;

&lt;p&gt;Для решения этих проблем разработчики придумали менеджеры версий. Менеджер версий – это специальная программа, предназначенная для управления версиями языка. С его помощью устанавливают нужные версии и производят переключение между ними. В отличие от пакетных менеджеров, входящих в операционные системы, менеджеры версий всегда позволяют ставить последние версии языков, как только они выходят (включая установку альфа- и бета-версий).&lt;/p&gt;

&lt;p&gt;Например, для Node.js это &lt;a href=&quot;https://github.com/nvm-sh/nvm&quot;&gt;NVM&lt;/a&gt; (Node Version Manager):&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Установка NVM&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-o-&lt;/span&gt; https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash
&lt;span class=&quot;c&quot;&gt;# Установка не означает активацию. После установки активной останется та версия, что и была до установки&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nvm &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;node &lt;span class=&quot;c&quot;&gt;# Установка последней доступной версии ноды&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nvm &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;6.14.4 &lt;span class=&quot;c&quot;&gt;# или 10.10.0, 8.9.1, и т.п.&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nvm ls-remote &lt;span class=&quot;c&quot;&gt;# список доступных версий&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nvm use node &lt;span class=&quot;c&quot;&gt;# Активация последней установленной версии ноды&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nvm use node 14.1 &lt;span class=&quot;c&quot;&gt;# Активация нужной версии&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Для упрощения работы менеджеры версий обычно позволяют создать специальный файл внутри проекта, который зафиксирует нужную версию языка. В некоторых случаях менеджеры версий сами отслеживают этот файл и переключают версию автоматически.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;14.1&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; .nvmrc
&lt;span class=&quot;c&quot;&gt;# Эта команда увидела файл .nvmrc и использовала указанную там версию&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nvm use
Found &lt;span class=&quot;s1&quot;&gt;&apos;/path/to/project/.nvmrc&apos;&lt;/span&gt; with version &amp;lt;14.1&amp;gt;
Now using node v14.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В современном мире сложно представить себе язык, у которого бы не было менеджера версий. Более того некоторые языки, такие как Ruby, имеют множество разных менеджеров версий, которые конкурируют между собой:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;go: gvm, g&lt;/li&gt;
  &lt;li&gt;java: jabba&lt;/li&gt;
  &lt;li&gt;ruby: rbenv, rvm, chruby&lt;/li&gt;
  &lt;li&gt;php: phpenv, phpbrew&lt;/li&gt;
  &lt;li&gt;python: pyenv&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Менеджеры версий позволили решить ещё несколько важных задач. Как правило, когда программист взаимодействует с языком, установленным напрямую, то ему приходится использовать &lt;em&gt;sudo&lt;/em&gt; при установке глобальных пакетов. Дело в том, что стандартная схема установки языка предназначена для всех пользователей сразу. Поэтому все нужные файлы, включая глобальные пакеты, попадают в общие директории для которых нужны права администратора. С точки зрения безопасности это довольно большая дыра, которой могут воспользоваться (и иногда пользуются) разработчики опенсорс библиотек. Менеджеры версий устанавливают всё в домашнюю директорию текущего пользователя, где у него и так полные права. С одной стороны это позволяет не запускать установку пакетов от имени администратора, а с другой — не засоряется система. Удалить язык и все его пакеты через менеджер версий невероятно просто. Достаточно стереть директорию (правда, лучше это делать средствами самого менеджера версий).&lt;/p&gt;

&lt;h2 id=&quot;универсальный-менеджер&quot;&gt;Универсальный менеджер&lt;/h2&gt;

&lt;p&gt;Решив одни проблемы, менеджеры версий добавили другие. Во-первых, их слишком много, и они иногда меняются, сначала популярен один, затем другой. Во-вторых, сам процесс установки менеджера версий может оказаться сложнее установки языка. Проблема в том, что им нужно быть универсальными и работать везде, что крайне проблематично, учитывая разнообразие современных экосистем. Достаточно посмотреть размер документации NVM, чтобы оценить масштаб катастрофы. В-третьих, все эти менеджеры работают по-разному и имеют разные команды. Из-за этого усложняется процесс переключения между ними при работе с разными языками.&lt;/p&gt;

&lt;p&gt;Всё это привело к следующему логическому шагу. В конце концов появился универсальный менеджер &lt;a href=&quot;https://asdf-vm.com/&quot;&gt;asdf&lt;/a&gt;, который, благодаря плагинам, способен работать с любыми языками. Неполный список его преимуществ:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Одна единственная утилита командной строки для работы со всеми языками&lt;/li&gt;
  &lt;li&gt;Единый интерфейс взаимодействия для всех языков&lt;/li&gt;
  &lt;li&gt;Автоматическое переключение на нужную версию языка внутри каждого проекта&lt;/li&gt;
  &lt;li&gt;Простая система плагинов, позволяющая добавить любые языки&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Сейчас &lt;em&gt;asdf&lt;/em&gt; набрал достаточно большую популярность и постепенно заменяет собой все остальные менеджеры версий (технически под капотом там часто используются менеджеры, специфические для конкретных языков). У него чуть более сложная система команд из-за необходимости поддерживать множество языков, но в остальном он резко упрощает весь процесс.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# У asdf прекрасная документация, где наглядно показано, как его установить,&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# и какие могут понадобится зависимости в разных системах&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Установка&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone https://github.com/asdf-vm/asdf.git ~/.asdf &lt;span class=&quot;nt&quot;&gt;--branch&lt;/span&gt; v0.7.8

&lt;span class=&quot;c&quot;&gt;# Для работы с конкретным языком, сначала нужно подключить соответствующий плагин&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Список доступных плагинов есть на сайте проекта&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;asdf plugin add nodejs

&lt;span class=&quot;c&quot;&gt;# Установка языка&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Вместо nodejs нужно подставить название того плагина, с которым работаем&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;asdf &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;nodejs latest &lt;span class=&quot;c&quot;&gt;# latest означает последнюю версию указанного языка&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Установка указанной версии&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;asdf &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;nodejs 14.1

&lt;span class=&quot;c&quot;&gt;# Установка нужной версии языка версией по умолчанию&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Здесь нужно всегда указывать конкретную версию&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;asdf global nodejs 14.1

&lt;span class=&quot;c&quot;&gt;# Показывает текущие версии для языков, установленных через asdf&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;asdf current
elixir         1.10.1-otp-22 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;by /Users/user/.tool-versions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
erlang         22.2.7   &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;by /Users/user/.tool-versions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
nodejs         14.2.0   &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;by /Users/user/.tool-versions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
php            7.4.5    &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;by /Users/user/.tool-versions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
python         3.8.2 2.7.16 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;by /Users/user/.tool-versions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
ruby           2.7.0    &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;by /Users/user/.tool-versions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
yarn           1.22.4   &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;by /Users/user/.tool-versions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;вывод&quot;&gt;Вывод&lt;/h2&gt;

&lt;p&gt;Работа с разными версиями языков – непростая задача, которую решают менеджеры версий и докер (для продвинутых). Среди всех менеджеров выделяется &lt;em&gt;asdf&lt;/em&gt;, который становится универсальным инструментом для управления любыми языками и даже обычными программами.&lt;/p&gt;</content><author><name>Кирилл Мокевнин</name></author><summary type="html">Системная установка</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://guides.hexlet.io/assets/images/version-manager/nvm.png" /><media:content medium="image" url="https://guides.hexlet.io/assets/images/version-manager/nvm.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Зачем нужно собирать фронтенд</title><link href="https://guides.hexlet.io/webpack/" rel="alternate" type="text/html" title="Зачем нужно собирать фронтенд" /><published>2020-06-27T00:00:00+00:00</published><updated>2020-06-27T00:00:00+00:00</updated><id>https://guides.hexlet.io/webpack</id><content type="html" xml:base="https://guides.hexlet.io/webpack/">&lt;p&gt;HTML поддерживает два способа работы с JavaScript. Первый – код добавляется прямо на страницу и второй – код загружается из файла указанного в теге &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;инлайновые-скрипты&quot;&gt;Инлайновые скрипты&lt;/h2&gt;

&lt;p&gt;Первый способ:&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;demo&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerHTML&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Hello JavaScript!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Он работает только в самых простых ситуациях. Иногда им пользуются для добавления небольших интерактивных элементов, таких как переключатели табов, автокомплиты и т.п.&lt;/p&gt;

&lt;h2 id=&quot;код-в-файлах&quot;&gt;Код в файлах&lt;/h2&gt;

&lt;p&gt;Современный фронтенд вышел далеко за пределы этих задач. Количество JavaScript кода во многих проектах достигает десяток и сотен тысяч строк кода. Такую массу кода физически невозможно поддерживать внутри HTML. Потому он располагается в отдельных файлах, которых может быть довольно много. Для их подключения используется второй способ:&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!--
Когда браузер встречает тег `&amp;lt;script&amp;gt;` с указанием `src`,
он загружает указанный файл и исполняет его.
Так код получает доступ к содержимому страницы.
--&amp;gt;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Все определения внутри становятся глобальны и доступны для всех остальных скриптов --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/assets/script1.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/assets/script2.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Тег &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt; был добавлен в HTML очень давно, задолго до появления современной версии языка с модулями. В те времена не существовало Node.js, пакетного менеджера и понятия “зависимости” (dependencies). Весь код писался в одном файле. Даже если файлов было несколько, они никак не были связаны друг с другом. Если попытаться использовать модули вместе с обычным тегом &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;, то браузер выдаст ошибку:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;Uncaught SyntaxError: Cannot use import statement outside a module
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В теории, код можно писать и без использования системы модулей, но этот способ невероятно трудозатратный и основывается на том, что все определения в коде глобальны (а значит, можно легко что-нибудь сломать, перетерев существующие определения). Придётся руками указывать все существующие файлы и загружать их в HTML, в строго определённом порядке. Подобное сейчас встречается только на сайтах, где фронтенд — это jquery с небольшим числом интерактивных элементов.&lt;/p&gt;

&lt;p&gt;Отсутствие модулей делает нормальную разработку невозможной. Нельзя работать с зависимостями, нельзя написать тесты, статический анализ кода отсутствует (невозможны переходы по определениям, подсказки).&lt;/p&gt;

&lt;h2 id=&quot;модули-в-браузере&quot;&gt;Модули в браузере&lt;/h2&gt;

&lt;p&gt;Проблема отсутствия модулей в браузере настолько важная, что в HTML5 ввели поддержку JavaScript-модулей. Достаточно в теге &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt; добавить &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type=&quot;module&quot;&lt;/code&gt;, как браузер начинает их понимать и загружать. Модули понимают практически все современные браузеры.&lt;/p&gt;

&lt;p&gt;В HTML:&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;module&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/assets/index.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В JavaScript:&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// index.js&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;./app.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// app.js&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Hello from module!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Модули в браузере кардинально всё меняют и позволяют работать с JavaScript так, как это нужно, если бы не одно серьёзное “но”. Система модулей в браузере не умеет работать с зависимостями. Если мы решим установить, например, lodash, то попытка его импортировать завершится с ошибкой. Решить эту проблему на уровне браузеров невозможно. Браузер ничего не знает про файловую систему и того, что там происходит.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;Uncaught TypeError: Failed to resolve module specifier &quot;lodash&quot;.
Relative references must start with either &quot;/&quot;, &quot;./&quot;, or &quot;../&quot;.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;сборщики-фронтенда&quot;&gt;Сборщики фронтенда&lt;/h2&gt;

&lt;p&gt;Эти проблемы полностью решают системы сборки. Кроме загрузки файлов, они решают множество других не менее важных задач. Фронтенд-разработка сильно опирается на различные пре- и пост-процессоры. Например, для современного JavaScript (и TypeScript) и многих фреймворков нужен Babel, который получает на вход исходный код проекта, преобразует его в код понятный браузеру. Только после этого его можно отдавать клиенту.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Указываем исходную директорию src&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# И директорию, в которую положить готовый код&lt;/span&gt;
babel src &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; dist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;То же самое касается CSS. Всё больше разработчиков используют SASS, который нужно транслировать в чистый CSS.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Указываем исходную директорию stylesheets&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# И директорию, в которую положить готовый CSS&lt;/span&gt;
sass &lt;span class=&quot;nt&quot;&gt;--update&lt;/span&gt; stylesheets dist/stylesheets
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Кроме этих задач, сборщики занимаются следующим:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Предоставляют единую команду для полной сборки фронтенда включая все его части.&lt;/li&gt;
  &lt;li&gt;Автоматически пересобирают фронтенд во время разработки. Делают это очень быстро благодаря использованию инкрементальной сборки (собирают только то, что поменялось).&lt;/li&gt;
  &lt;li&gt;Обеспечивают производительность. Минифицируют и сжимают код (в том числе удаляя неиспользуемый). Разбивают его максимально удобным для кеширования способом.&lt;/li&gt;
  &lt;li&gt;Выполняют любые преобразования, например, TypeScript =&amp;gt; JavaScript. Позволяют подключать пре- и пост-процессоры, настроить порядок их применения к выбранным файлам.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если выполнять эти задачи вручную, то подготовка кода к запуску в браузере станет занимать больше времени, чем сама разработка.&lt;/p&gt;

&lt;h2 id=&quot;webpack&quot;&gt;Webpack&lt;/h2&gt;

&lt;p&gt;Одним из первых сборщиков фронтенда стал Webpack. Сейчас он стандарт де-факто в среде фронтенда, хотя существуют и другие решения. Общий принцип работы вебпака такой. В проекте устанавливается сам вебпак и описывается его конфигурация. Эта конфигурация содержит все правила сборки: какие файлы брать, какие обработчики к ним применять и куда складывать результат. На выходе вебпак формирует файл или набор файлов, готовых для загрузки в браузер. Дальше он не участвует, использование этих файлов – задача программиста.&lt;/p&gt;

&lt;p&gt;Webpack поставляется как npm-библиотека и устанавливается в проект, обычно, в dev-зависимости, а для работы удобно использовать cli-утилиту:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;webpack-demo
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;webpack-demo
npm init &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt;
npm i &lt;span class=&quot;nt&quot;&gt;-D&lt;/span&gt; webpack webpack-cli @webpack-cli/init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь можно инициализировать новый вебпак-проект, который автоматически создаст все необходимые файлы и конфигурацию одной командой:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;npx webpack init &lt;span class=&quot;nt&quot;&gt;--auto&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Она предложит перезаписать &lt;em&gt;package.json&lt;/em&gt;, добавит в проект несколько зависимостей, создаст HTML и JS-файлы, а также создаст конфигурационный файл. Запуск этой же команды без флага &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--auto&lt;/code&gt; откроет интерактивный режим, где можно более тонко настроить будущее приложение.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;npx webpack init

Just found a &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;.yo-rc.json&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;a parent directory.
Setting the project root at: /home/hexlet/webpack-demo
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;webpack-cli] 
ℹ INFO  For more information and a detailed description of each question, have a look at: https://github.com/webpack/webpack-cli/blob/master/INIT.md
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;webpack-cli] ℹ INFO  Alternatively, run &lt;span class=&quot;s2&quot;&gt;&quot;webpack(-cli) --help&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;usage info

? Will your application have multiple bundles? No
? Which will be your application entry point? src/index
? In which folder &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;you want to store your generated bundles? dist
? Will you use one of the below JS solutions? ES6
? Will you use one of the below CSS solutions? No

&lt;span class=&quot;c&quot;&gt;# вывод об установке библиотек&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;webpack-cli] 
Congratulations! Your new webpack configuration file has been created!

You can now run npm run build to bundle your application!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Проект готов и теперь его можно запустить:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;npx webpack serve
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Эта команда соберёт приложение в режиме разработки, откроет браузер и отобразит содержимое HTML-файла, а в консоль выведется сообщение из &lt;em&gt;src/index.js&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/webpack/init-app.png&quot; alt=&quot;Запущенное в браузере Webpack-приложение&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Конфигурационный файл &lt;em&gt;webpack.config.js&lt;/em&gt; будет содержать несколько плагинов, необходимых для работы с HTML. Всё готово, чтобы написать своё первое фронтенд-приложение, используя Webpack!&lt;/p&gt;

&lt;p&gt;Лучший способ продолжить с ним работу — это читать &lt;a href=&quot;https://webpack.js.org/guides/getting-started/#basic-setup&quot;&gt;официальную документацию&lt;/a&gt; и изучить &lt;a href=&quot;https://github.com/hexlet-boilerplates/webpack-package&quot;&gt;Webpack Boilerplate&lt;/a&gt;, созданный Хекслетом.&lt;/p&gt;</content><author><name>Кирилл Мокевнин</name></author><summary type="html">HTML поддерживает два способа работы с JavaScript. Первый – код добавляется прямо на страницу и второй – код загружается из файла указанного в теге &amp;lt;script&amp;gt;.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://guides.hexlet.io/assets/images/webpack/webpack.png" /><media:content medium="image" url="https://guides.hexlet.io/assets/images/webpack/webpack.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Что такое кодировки?</title><link href="https://guides.hexlet.io/encoding/" rel="alternate" type="text/html" title="Что такое кодировки?" /><published>2020-04-15T00:00:00+00:00</published><updated>2020-04-15T00:00:00+00:00</updated><id>https://guides.hexlet.io/encoding</id><content type="html" xml:base="https://guides.hexlet.io/encoding/">&lt;h2 id=&quot;почему-кодировки---это-важно&quot;&gt;Почему кодировки - это важно?&lt;/h2&gt;

&lt;p&gt;Компьютеры постоянно работают с текстами: это ленты новостных сайтов, фондовые биржи, сообщения в социальных сетях и мессенджерах, банковские приложения и многое другое. Сегодня мы не можем представить жизнь без передачи информации. Но так было не всегда. Компьютеры научились работать с текстом благодаря появлению кодировок. Кодировки прошли большой путь от таблиц символов, созданных отдельно для каждого компьютера, до единой кодировки, принятой во всём мире.&lt;/p&gt;

&lt;p&gt;Сейчас Unicode — это основной стандарт кодирования символов, включающий в себя знаки почти всех письменных языков мира. Unicode применяется везде, где есть текст. Информация на страницах в социальных сетях, записи в базах данных, компьютерные программы и мобильные приложения — всё это работает с использованием Unicode.&lt;/p&gt;

&lt;p&gt;В этом гайде мы рассмотрим, как появился Unicode и какие проблемы он решает. Узнаем, как хранилась и передавалась информация до введения единого стандарта кодирования символов, а также рассмотрим примеры кодировок, основанных на Unicode.&lt;/p&gt;

&lt;h2 id=&quot;предпосылки-появления-кодировок&quot;&gt;Предпосылки появления кодировок&lt;/h2&gt;

&lt;p&gt;Исторически компьютер создавался как машина для ускорения и автоматизации вычислений. Само слово computer с английского можно перевести как вычислитель, а в 20 веке в СССР, до распространения термина компьютер, использовалась аббревиатура ЭВМ — электронно вычислительная машина.&lt;/p&gt;

&lt;p&gt;Всё, чем компьютеры оперировали — числа. Основным заказчиком и драйвером появления первых моделей были оборонные предприятия. На компьютерах проводили расчёты параметров полёта баллистических ракет, самолётов, спутников. В 1950-е годы вычислительные мощности компьютеров стали использовать для:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;прогноза погоды;&lt;/li&gt;
  &lt;li&gt;вычислений экспериментальной и теоретической физики;&lt;/li&gt;
  &lt;li&gt;расчета заработной платы сотрудников (например, компьютер LEO применялся для нужд компании, владеющей сетью чайных магазинов);&lt;/li&gt;
  &lt;li&gt;прогнозирование результатов выборов президента США (1952 год, компьютер UNIVAC).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;компьютеры-и-числа&quot;&gt;Компьютеры и числа&lt;/h3&gt;

&lt;p&gt;Цели, для которых разрабатывались компьютеры, привели к появлению архитектуры, предназначенной для работы с числами. Они хранятся в компьютере следующим образом:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Число из десятичной системы счисления переводится в двоичную, т.е. набор нулей и единиц. Например, 3 в двоичной системе счисления можно записать в виде 11, а 9 как 1001. Подробнее о системах счисления читайте в соответствующем гайде.&lt;/li&gt;
  &lt;li&gt;Полученный набор нулей и единиц хранится в ячейках памяти компьютера. Например, наличие тока на элементе памяти означает единицу, его отсутствие — ноль.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/encoding/enter-number.png&quot; alt=&quot;картинка о записи чисел в память&quot; /&gt;&lt;/p&gt;

&lt;p&gt;В конце 1950-х годов происходит замена ламп накаливания на полупроводниковые элементы (транзисторы и диоды). Внедрение новой технологии позволило уменьшить размеры компьютеров, увеличить скорость работы и надёжность вычислений, а также повлияло на конечную стоимость. Если первые компьютеры были дорогостоящими штучными проектами, которые могли себе позволить только государства или крупные компании, то с применением полупроводников начали появляться серийные компьютеры, пусть даже и не персональные.&lt;/p&gt;

&lt;h3 id=&quot;компьютеры-и-символы&quot;&gt;Компьютеры и символы&lt;/h3&gt;

&lt;p&gt;Постепенно компьютеры начинают применяться для решения не только вычислительных или математических задач. Возникает необходимость обработки текстовой информации, но с буквами и другими символами ситуация обстоит сложнее, чем с числами. Символы — это визуальный объект. Даже одна и та же буква «а» может быть представлена двумя различными символами «а» и «А» в зависимости от регистра.&lt;/p&gt;

&lt;p&gt;Также число «один» можно представить в виде различных символов. Это может быть арабская цифра 1 или римская цифра I. Значение числа не меняется, но символы используются разные.&lt;/p&gt;

&lt;p&gt;Компьютеры создавались для работы с числами, они не могут хранить символы. При вводе информации в компьютер символы преобразуются в числа и хранятся в памяти компьютера как обычные числа, а при выводе информации происходит обратное преобразование из чисел в символы.&lt;/p&gt;

&lt;p&gt;Правила преобразования символов и чисел хранились в виде таблицы символов (англ. charset). В соответствии с такой таблицей для каждого компьютера конструировали и своё уникальное устройство ввода/вывода информации (например, клавиатура и принтер).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/encoding/enter-symbol.png&quot; alt=&quot;Картинка о записи символов в память&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;распространение-компьютеров&quot;&gt;Распространение компьютеров&lt;/h3&gt;

&lt;p&gt;В начале 1960-х годов компьютеры были несовместимы друг с другом даже в рамках одной компании-производителя. Например, в компании IBM насчитывалось около 20 конструкторских бюро, и каждое разрабатывало свою собственную модель. Такие компьютеры не были универсальными, они создавались для решения конкретных задач. Для каждой решаемой задачи формировалась необходимая таблица символов, и проектировались устройства ввода/вывода информации.&lt;/p&gt;

&lt;p&gt;В этот период начинают формироваться сети, соединяющие в себе несколько компьютеров. Так, в 1958 году создали систему SAGE (Semi-Automatic Ground Environment), объединившую радарные станций США и Канады в первую крупномасштабную компьютерную сеть. При этом, чтобы результаты вычислений одних компьютеров можно было использовать на других компьютерах сети, они должны были обладать одинаковыми таблицами символов.&lt;/p&gt;

&lt;p&gt;В 1962 году компания IBM формирует два главных принципа для развития собственной линейки компьютеров:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Компьютеры должны стать универсальными. Это означало переход от производства узкоспециализированных компьютеров к машинам, которые могут решать разные задачи.&lt;/li&gt;
  &lt;li&gt;Компьютеры должны стать совместимыми друг с другом, то есть должна быть возможность использовать данные с одного компьютера на другом.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Так в 1965 году появились компьютеры IBM System/360. Это была линейка из шести моделей, состоящих из совместимых модулей. Модели различались по производительности и стоимости, что позволило заказчикам гибко подходить к выбору компьютера. Модульность систем привела к появлению новой отрасли — производству совместимых с System/360 вычислительных модулей. У компаний не было необходимости производить компьютер целиком, они могли выходить на рынок с отдельными совместимыми модулями. Всё это привело к ещё большему распространению компьютеров.&lt;/p&gt;

&lt;h2 id=&quot;ascii-как-первый-стандарт-кодирования-информации&quot;&gt;ASCII как первый стандарт кодирования информации&lt;/h2&gt;

&lt;h3 id=&quot;телетайп-и-терминал&quot;&gt;Телетайп и терминал&lt;/h3&gt;

&lt;p&gt;Параллельно с этим развивались телетайпы. Телетайп — это система передачи текстовой информации на расстоянии. Два принтера и две клавиатуры (на самом деле электромеханические печатные машинки) попарно соединялись друг с другом проводами. Текст, набранный на клавиатуре у первого пользователя, печатается на принтере у второго пользователя и наоборот. Таким образом, например, была организована «горячая линия» между президентом США и руководством СССР вплоть до начала 1970-х годов.&lt;/p&gt;

&lt;p&gt;Телетайпы также преобразуют текстовую информацию в некоторые сигналы, которые передаются по проводам. При этом не всегда используется бинарный код, например, в азбуке Морзе используются 3 символа — точка, тире и пауза. Для телетайпов необходимы таблицы символов, соответствие в которых строится между символами и сигналами в проводах. При этом для каждого телетайпа (пары, соединённых телетайпов) таблицы символов могли быть свои, исходя из задач, которые они решали. Отличаться, например, мог язык, а значит и сам набор символов, который отправлялся с помощью устройства. Для оптимизации работы телетайпа самые популярные (часто встречающиеся) символы кодировались наиболее коротким набором сигналов, а значит и в рамках одного языка, набор символов мог быть разным.&lt;/p&gt;

&lt;p&gt;На основе телетайпов разработали терминалы доступа к компьютерам. Такой телетайп отправлял сообщения не второму пользователю, а информация вводилась на некоторый удалённый компьютер, который после обработки указанных команд, возвращал результат в виде ответного сообщения. Это нововведение позволило использовать тогда ещё очень дорогие вычислительные мощности компьютеров, не имея физического доступа к самому компьютеру. Например, компьютер мог размещаться в отдельном вычислительном центре корпорации или института, а сотрудники из других филиалов или городов получали доступ к вычислительным мощностями компьютера посредством установленных у них терминалов.&lt;/p&gt;

&lt;h3 id=&quot;ascii&quot;&gt;ASCII&lt;/h3&gt;

&lt;p&gt;Повсеместное распространение компьютеров и средств обмена текстовой информацией потребовало разработки единого стандарта кодирования для передачи и хранения информации. Такой стандарт разработали в США в 1963 году. Таблицу из 128 символов назвали ASCII — American standard code for information interchange (Американский стандарт кодов для обмена информацией).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/encoding/ASCII_Code_Chart.png&quot; alt=&quot;ASCII image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Первые 32 символа в ASCII являются управляющими. Они использовались для того, чтобы, например, управлять печатающим устройством телетайпа и получать некоторые составные символы. Например:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;символ Ø можно было получить так: печатаем O, затем с помощью управляющего кода BS (BackSpace) передвигаем печатную головку на один символ назад и печатаем символ /,&lt;/li&gt;
  &lt;li&gt;символ à получался как a BS `&lt;/li&gt;
  &lt;li&gt;символ Ç получался как C BS ,&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Введение управляющих символов позволяло получать новые символы как комбинацию существующих, не вводя дополнительные таблицы символов.&lt;/p&gt;

&lt;p&gt;Однако введение стандарта ASCII решило вопрос только в англоговорящих странах. В странах с другой письменностью, например, с кириллической в СССР, проблема оставалась.&lt;/p&gt;

&lt;h3 id=&quot;кодировки-для-других-языков&quot;&gt;Кодировки для других языков&lt;/h3&gt;

&lt;p&gt;В течение более чем 20 лет вопрос решали введением собственных локальных стандартов, например, в СССР на основе таблицы ASCII разработали собственные варианты кодировок КОИ 7 и КОИ 8, где 7 и 8 указывают на количество бит, необходимых для кодирования одного символа, а КОИ расшифровывается как Коды Обмена Информацией.&lt;/p&gt;

&lt;p&gt;С дальнейшим развитием систем начали использовать восьмибитные кодировки. Это позволило использовать наборы, содержащие по 256 символов. Достаточно распространён был подход, при котором первые 128 символов брали из стандарта ASCII, а оставшиеся 128 дополнялись собственными символами. Такое решение, в частности, было использовано в кодировке KOI 8.&lt;/p&gt;

&lt;p&gt;Однако единым стандартом указанные кодировки так и не стали. Например, в MS-DOS для русских локализаций использовалась кодировка cp866, а далее в среде MS Windows стали использоваться кодировки cp1251. Для греческого языка применялись кодировки cp851 и cp1253. В результате документы, подготовленные с использованием старой кодировки, становились нечитаемыми на новых.&lt;/p&gt;

&lt;p&gt;Свои кодировки необходимы и для других стран с уникальным набором символов. Это приводило к путанице и сложностям в обмене информацией. Ниже приведён пример текста, который написали в кодировке KOI8-R, а читают в cp851.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;KOI8-R&lt;/th&gt;
      &lt;th&gt;cp851&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;English text.&lt;/td&gt;
      &lt;td&gt;English text.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Это - русский текст :-).&lt;/td&gt;
      &lt;td&gt;ΰΨΣ - ΦΩΧΧ╦╔╩ Ψ┼╦ΧΨ :-).&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/encoding/forward-information.png&quot; alt=&quot;Картинка для кодировок&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Обе кодировки основаны на стандарте ASCII, поэтому знаки препинания и буквы английского алфавита в обеих кодировках выглядят одинаково. Кириллический текст при этом становится совершенно нечитаемым.&lt;/p&gt;

&lt;p&gt;При этом компьютерная память была дорогой, а связь между компьютерами медленной. Поэтому выгоднее было использовать кодировки, в которых размер в битах каждого символа был небольшим. Таблица символов состоит из 256 символов. Это значит, что нам достаточно 8 бит для кодирования любого из них (2^8 = 256).&lt;/p&gt;

&lt;h2 id=&quot;переход-к-unicode&quot;&gt;Переход к Unicode&lt;/h2&gt;

&lt;p&gt;Развитие интернета, увеличение количества компьютеров и удешевление памяти привели к тому, что проблемы, которые доставляла путаница в кодировках, стали перевешивать некоторую экономию памяти. Особенно ярко это проявлялось в интернете, когда текст написанный на одном компьютере должен был корректно отображаться на многих других устройствах. Это доставляло огромные проблемы как программистам, которые должны были решать какую кодировку использовать, так и конечным пользователям, которые не могли получить доступ к интересующим их текстам.&lt;/p&gt;

&lt;p&gt;В результате в октябре 1991 года появилась первая версия одной общей таблицы символов, названной Unicode. Она включала в себя на тот момент 7161 различный символ из 24 письменностей мира.&lt;/p&gt;

&lt;p&gt;В Unicode постепенно добавлялись новые языки и символы. Например, в версию 1.0.1 в середине 1992 года добавили более 20 000 идеограмм китайского, японского и корейского языков. В актуальной на текущий момент версии содержится уже более 143 000 символов.&lt;/p&gt;

&lt;h2 id=&quot;кодировки-на-основе-unicode&quot;&gt;Кодировки на основе Unicode&lt;/h2&gt;

&lt;p&gt;Unicode можно себе представить как огромную таблицу символов. В памяти компьютера записываются не сами символы, а номера из таблицы. Записывать их можно разными способами. Именно для этого на основе Unicode разработаны несколько кодировок, которые отличаются способом записи номера символа Unicode в виде набора байт. Они называются UTF — Unicode Transformation Format. Есть кодировки постоянной длины, например, UTF-32, в которой номер любого символа из таблицы Unicode занимает ровно 4 байта. Однако наибольшую популярность получила UTF-8 — кодировка с переменным числом байт. Она позволяет кодировать символы так, что наиболее распространённые символы занимают 1-2 байта, и только редко встречающиеся символы могут использовать по 4 байта. Например, все символы таблицы ASCII занимают ровно по одному байту, поэтому текст, написанный на английском языке с использованием кодировки UTF-8, будет занимать столько же места, как и текст, написанный с использованием таблицы символов ASCII.&lt;/p&gt;

&lt;p&gt;На сегодняшний день Unicode является основной кодировкой, которую используют в работе все, кто связан с компьютерами и текстами. Unicode позволяет использовать сотни тысяч различных символов и отображать их одинаково на всех устройствах от мобильных телефонов до компьютеров на космических станциях.&lt;/p&gt;

&lt;h2 id=&quot;резюме&quot;&gt;Резюме&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Кодировка — это соответствие между визуальными символами и числами.&lt;/li&gt;
  &lt;li&gt;Кодировки необходимы, так как компьютеры созданы для работы с числами и не понимают текст.&lt;/li&gt;
  &lt;li&gt;До 1990-х годов не существовало единой кодировки, это приводило к тому, что текст, написанный в одной кодировке, становится совершенно нечитаемым на других.&lt;/li&gt;
  &lt;li&gt;Unicode — единый стандарт кодирования символов. Развитие интернета и необходимость обмена большим количеством текстовой информации приводило к тому, что сейчас все пользуются этим стандартом.&lt;/li&gt;
  &lt;li&gt;UTF-8, UTF-16, UTF-32 и т.п. — это варианты кодировок, основанные на Unicode. Отличаются они тем, что по-разному хранят информацию.&lt;/li&gt;
  &lt;li&gt;UTF-8 — самая популярная кодировка. Особенность её в том, что самые популярные символы кодируются 1-2 байтами, а редко встречающиеся занимают 3-4 байта. Это приводит к существенной экономии памяти, например, при работе с английским текстом.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ильнар Шафигуллин</name></author><summary type="html">Почему кодировки - это важно?</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://guides.hexlet.io/assets/images/encoding/Unicode-Logo.jpg" /><media:content medium="image" url="https://guides.hexlet.io/assets/images/encoding/Unicode-Logo.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Несколько версий Python на Linux-машине</title><link href="https://guides.hexlet.io/unix-multipython/" rel="alternate" type="text/html" title="Несколько версий Python на Linux-машине" /><published>2019-09-01T00:00:00+00:00</published><updated>2019-09-01T00:00:00+00:00</updated><id>https://guides.hexlet.io/unix-multipython</id><content type="html" xml:base="https://guides.hexlet.io/unix-multipython/">&lt;h3 id=&quot;использование-нескольких-версий-python-на-unix-подобных-операционных-системах&quot;&gt;Использование нескольких версий Python на unix-подобных операционных системах.&lt;/h3&gt;

&lt;h4 id=&quot;что-и-зачем&quot;&gt;Что и зачем?&lt;/h4&gt;

&lt;p&gt;Python как язык постоянно развивается. Ветка Py2 скоро будет объявлена неподдерживаемой. Однако до сих пор существуют окружения, где приходится использовать Py2 и даже не свежий 2.7.x, а что-то по-старее. Да и Python 3.x нынче — это большое семейство версий, кое-где несовместимых между собой, в т.ч. и синтаксически! Поэтому практикующий питонист широкого профиля должен понимать, как на одной машине иметь несколько версий среды исполнения. Даже если “в продакшне” и используется какой-нибудь Docker!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/python-2-and-3-logo.png&quot; alt=&quot;logo&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;установка-python-из-репозиториев-пакетов-операционной-системы&quot;&gt;Установка Python из репозиториев пакетов операционной системы.&lt;/h4&gt;

&lt;p&gt;Если вам повезло, то в репозитории пакетов ОС будет нужная версия Python и вы сможете её установить с помощью команды вроде &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo apt-get install python3.5&lt;/code&gt;. Однако достаточно старые &lt;a href=&quot;https://ru.wikipedia.org/wiki/Дистрибутив_Linux&quot;&gt;дистрибутивы ОС&lt;/a&gt; могут не содержать новых версий Python, а достаточно новые дистрибутивы — старых версий Python. В особых случаях репозиторий вообще может содержать только одну версию среды исполнения.&lt;/p&gt;

&lt;h4 id=&quot;сборка-из-исходного-кода&quot;&gt;Сборка из исходного кода.&lt;/h4&gt;

&lt;p&gt;CPython — проект с исходным кодом. Доступ к исходному коду всех версий CPython позволяет собрать нужную версию самостоятельно. Однако это процесс, пусть и достаточно хорошо документирован, но всё же требует понимания того, что вам может потребоваться для компиляции кода под вашу операционную систему.&lt;/p&gt;

&lt;p&gt;А ещё сборка из исходного кода — это единственный вариант для тех, кто хочет что-то в этом самом коде изменить или скомпилировать интерпретатор для какой-то экзотической платформы (встраиваемые системы, ретро-железо).&lt;/p&gt;

&lt;h4 id=&quot;pyenv&quot;&gt;pyenv&lt;/h4&gt;

&lt;p&gt;Ещё одним из способов получения разных версий среды исполнения на одной машине является &lt;a href=&quot;https://github.com/pyenv/pyenv&quot;&gt;pyenv&lt;/a&gt;. Это “менеджер версий”, выполненный в стиле rbenv для Ruby, nvm для NodeJS и т.п.&lt;/p&gt;

&lt;p&gt;Миссия pyenv — управлять установленными версиями Python и делать некую версию “активной”. Активная версия вызывается, если мы выполняем команду &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt; (а также &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pip&lt;/code&gt;), при этом разные проекты могут использовать разные активные версии и даже более чем одну одновременно. Последнее свойство полезно авторам библиотек, рассчитанных на широкий круг пользователей — таковые &lt;em&gt;всегда нужно тестировать на разных версиях&lt;/em&gt; Python.&lt;/p&gt;

&lt;p&gt;Установить pyenv достаточно просто, ведь инструмент представляет собой набор shell scripts. Именно поэтому получился pyenv максимально кроссплатформенным. Но за эту кроссплатформенность приходится платить тем, что каждую версию среды исполнения &lt;em&gt;нужно компилировать из исходного кода&lt;/em&gt;! Для компиляции того же CPython потребуется компилятор Си (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gcc&lt;/code&gt; на Linux и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clang&lt;/code&gt; на MacOS), и &lt;a href=&quot;https://ru.wikipedia.org/wiki/Заголовочный_файл&quot;&gt;заголовочные файлы&lt;/a&gt; для библиотек, которые использует интерпретатор. Полный список пререквизитов для сборки приходится гуглить.&lt;/p&gt;

&lt;h4 id=&quot;установка-системным-пакетным-менеджером-из-сторонних-источников&quot;&gt;Установка системным пакетным менеджером из сторонних источников.&lt;/h4&gt;

&lt;p&gt;Для большинства Unix-like ОС, помимо официальных репозиториев, существуют и неофициальные источники пакетов.&lt;/p&gt;

&lt;p&gt;Для Debian-like систем, таких как Ubuntu и её производные, сторонние источники пакетов называются &lt;em&gt;PPA, Personal Package Archives&lt;/em&gt;. Подключить любой PPA достаточно просто, но нужно понимать, что вы таким образом соглашаетесь на установку пакетов из стороннего источника, никак не подчиняющегося авторам дистрибутива ОС! Подключайте только хорошо зарекомендовавшие себя PPA, например — от самих авторов ПО, которое вы хотите установить!&lt;/p&gt;

&lt;p&gt;Для Ubuntu-based систем существует &lt;a href=&quot;https://launchpad.net/~deadsnakes/+archive/ubuntu/ppa&quot;&gt;PPA от команды “deadsnakes”&lt;/a&gt;. Это проверенный источник пакетов с самыми разными версиями Python как для свежих релизов ОС, так и для релизов “второй свежести”.&lt;/p&gt;

&lt;p&gt;Главное преимущество установки пакетов из проверенных PPA состоит в том, что пакеты обычно содержат оптимизированные под конкретный дистрибутив сборки с должным количеством обновлений и исправлений. Такие сборки более безопасны и производительны, чем те, что собраны вручную из исходников.&lt;/p&gt;

&lt;p&gt;К тому же в популярных PPA пакеты обновляются своевременно, чего нельзя сказать про пакеты для устаревших релизов ОС, для которых срок поддержки закончился. Конечно, такие релизы лучше вообще не использовать (небезопасно!), но иногда может не быть выбора, а с PPA вы хотя бы будете иметь свежие версии среды исполнения.&lt;/p&gt;

&lt;h4 id=&quot;псевдонимы-python-python2-python3&quot;&gt;Псевдонимы &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python2&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python3&lt;/code&gt;.&lt;/h4&gt;

&lt;p&gt;Исторически сложилось так, что интерпретатор Python запускается командой &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt;. Но в какой-то момент случились Python3, обратная несовместимость, “разброд и шатания”. Чтобы внести некоторую определённость, был представлен &lt;a href=&quot;https://www.python.org/dev/peps/pep-0394/&quot;&gt;PEP-394&lt;/a&gt;: &lt;em&gt;The “python” Command on Unix-Like Systems&lt;/em&gt;. Однако даже этот PEP разрешает разным системам &lt;em&gt;самим выбирать&lt;/em&gt;, использовать ли Py2 и Py3 вместе или выбрать что-то одно. Системы должны лишь обеспечить, чтобы&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;команда &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python2&lt;/code&gt; вызывала некую версию Python 2.x, если таковая вообще предоставляется;&lt;/li&gt;
  &lt;li&gt;команда &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python3&lt;/code&gt; вызывала некую версию Python 3.x, если таковая предоставляется;&lt;/li&gt;
  &lt;li&gt;команда &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt; соответствовала либо &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python2&lt;/code&gt;, либо &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python3&lt;/code&gt; (но не ссылалась на какую-то “третью” версию рантайма).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;При этом не гарантируется, что все эти команды будут присутствовать в конкретном случае: где-то будет доступна только команда &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python3&lt;/code&gt;, где-то — &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python2&lt;/code&gt;. Псевдоним &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt; вообще &lt;em&gt;обязан присутствовать лишь в виртуальном окружении&lt;/em&gt; и всегда соответствовать той версии интерпретатора, которая &lt;em&gt;была выбрана при создании окружения&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Такое “разнообразие” сильно усложняет жизнь разработчикам ПО, особенно — авторам инструментов разработки! Разработчик может написать скрипт для Py2 и указать в &lt;a href=&quot;https://ru.wikipedia.org/wiki/Шебанг_(Unix)&quot;&gt;shebang&lt;/a&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#!/usr/bin/env python&lt;/code&gt;. Но на одних ОС команда &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt; вообще не будет доступна и скрипт просто не запустится, а на других &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt; будет означать какой-нибудь Python 3.8 и скрипт может даже запуститься, но сломается в процессе выполнения.&lt;/p&gt;

&lt;p&gt;И даже если автор использует техники, позволяющие писать портируемый код (&lt;a href=&quot;https://pypi.org/project/six/&quot;&gt;six&lt;/a&gt;, &lt;a href=&quot;https://pypi.org/project/3to2/&quot;&gt;3to2&lt;/a&gt;), умеющий выполняться и на Py2, и на Py3, всё равно непонятно что же указать в shebang!&lt;/p&gt;

&lt;p&gt;Вышеупомянутый PEP советует&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;либо фиксировать версию явно (только Py2 или только Py3),&lt;/li&gt;
  &lt;li&gt;либо требовать использования виртуальных окружений (в ВО всегда будет доступна команда &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;либо не писать shebang руками, а вместо этого использовать средства setuptools или другой системы пакетирования, создающие точки входа в зависимости при установке пакета (у точек входа shebang будет правильный).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;установка-poetry-на-системы-с-разными-версиями-python&quot;&gt;Установка poetry на системы с разными версиями Python&lt;/h3&gt;

&lt;p&gt;На момент написания статьи poetry (это такой менеджер виртуальных окружений, сборщик пакетов и проч — “швейцарский нож” разработчика на Python) страдал от проблем с версиями рантайма: при установке рекомендованными способом скрипт-установщик завершался с ошибкой, либо установка проходила успешно, но затем не работала сама программа.&lt;/p&gt;

&lt;p&gt;Дело (было?) в том, что и в скрипте-установщике и в точках входа в программу в shebang прописан &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt;! Сама программа работает и на Py2, и на Py3, но авторы исходили из предположения, что на целевой системе в любом случае будет присутствовать псевдоним &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt;, вызывающий тот или иной интерпретатор. На некоторых системах такой команды нет…&lt;/p&gt;

&lt;p&gt;Если использовать pyenv, оный всегда предоставляет команду &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt; и poetry “просто работает”. Нет проблем и на старых дистрибутивах, где ещё не отказались окончательно от &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Py2&lt;/code&gt;. И конечно всё работает в виртуальном окружении. Рассмотрим этот вариант поподробнее.&lt;/p&gt;

&lt;h4 id=&quot;установка-в-выделенное-виртуальное-окружение&quot;&gt;Установка в выделенное виртуальное окружение&lt;/h4&gt;

&lt;p&gt;Для начала нам понадобится само окружение. Предположим, что Python3 вы уже так или иначе поставили. Делаем раз&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python3 &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; venv &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/.poetry.venv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Делаем два&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ $HOME&lt;/span&gt;/.poetry.venv/bin/pip &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;poetry
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Проверяем&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ $HOME&lt;/span&gt;/.poetry.venv/bin/poetry &lt;span class=&quot;nt&quot;&gt;--version&lt;/span&gt;
Poetry 0.12.17
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Программа установлена! Теперь создаём символическую ссылку на точку входа в папке, видимой в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PATH&lt;/code&gt;, например, в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$HOME/.local.bin&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/.poetry.venv/bin/poetry &lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;/.local/bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Проверяем&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;poetry &lt;span class=&quot;nt&quot;&gt;--version&lt;/span&gt;
Poetry 0.12.17
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Работает! Обновлять программу в будущем можно с помощью того же &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pip&lt;/code&gt; (который в окружении). А можно и вовсе автоматизировать процесс установки такого вот Python-софта с помощью &lt;a href=&quot;https://pipxproject.github.io/pipx/&quot;&gt;pipx&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;особенности-использования-poetry-установленного-в-виртуальное-окружение&quot;&gt;Особенности использования poetry, установленного в виртуальное окружение.&lt;/h4&gt;

&lt;p&gt;Poetry построен так, чтобы работать с абстрактной версией python. Поэтому он хорошо сочетается с pyenv: один на себя берёт управление разными пайтонами, а другой — проектами на этих пайтонах.&lt;/p&gt;

&lt;p&gt;Но эта привязка к команде &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt; немного мешает, когда poetry установлен в своём собственном виртуальном окружении: в этом окружении Python уже известен и не может быть изменён. Данная особенность упомянута в документации к poetry, так что это “не баг, а фича”. И всё же есть способ обойти сие ограничение: можно инициализировать окружение вручную с нужной версией Python и настроить poetry на использование этого готового окружения.&lt;/p&gt;

&lt;p&gt;Для начала учим poetry создавать окружения не в своём кэше, а в папке с проектом:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;poetry config settings.virtualenvs.in-project &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;С этих пор для каждого проекта виртуальное окружение будет располагаться в поддиректории &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.venv&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Уже в конкретном проекте инициализируем окружение командой&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python3 &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; venv .venv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(для Py2 команда будет другой, т.к. модуль &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;venv&lt;/code&gt; тогда ещё не поставлялся вместе со средой исполнения).&lt;/p&gt;

&lt;p&gt;Теперь можно работать с poetry как обычно. Несмотря на то, что Python в проекте, возможно, отличается от рантайма, запускающего poetry!&lt;/p&gt;</content><author><name>Кирилл Мокевнин</name></author><summary type="html">Использование нескольких версий Python на unix-подобных операционных системах.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://guides.hexlet.io/assets/images/python-2-and-3-logo.png" /><media:content medium="image" url="https://guides.hexlet.io/assets/images/python-2-and-3-logo.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>